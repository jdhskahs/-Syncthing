// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: folderconfiguration.proto

package config

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	fs "lib/fs"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type FolderDeviceConfiguration struct {
}

func (m *FolderDeviceConfiguration) Reset()         { *m = FolderDeviceConfiguration{} }
func (m *FolderDeviceConfiguration) String() string { return proto.CompactTextString(m) }
func (*FolderDeviceConfiguration) ProtoMessage()    {}
func (*FolderDeviceConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b3c31ccb4dec1d6, []int{0}
}
func (m *FolderDeviceConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FolderDeviceConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FolderDeviceConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FolderDeviceConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FolderDeviceConfiguration.Merge(m, src)
}
func (m *FolderDeviceConfiguration) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FolderDeviceConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_FolderDeviceConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_FolderDeviceConfiguration proto.InternalMessageInfo

type FolderConfiguration struct {
	//
	//ID                      string                      `xml:"id,attr" json:"id"`
	//Label                   string                      `xml:"label,attr" json:"label" restart:"false"`
	//FilesystemType          fs.FilesystemType           `xml:"filesystemType" json:"filesystemType"`
	//Path                    string                      `xml:"path,attr" json:"path"`
	//Type                    FolderType                  `xml:"type,attr" json:"type"`
	//Devices                 []FolderDeviceConfiguration `xml:"device" json:"devices"`
	//RescanIntervalS         int                         `xml:"rescanIntervalS,attr" json:"rescanIntervalS" default:"3600"`
	//FSWatcherEnabled        bool                        `xml:"fsWatcherEnabled,attr" json:"fsWatcherEnabled" default:"true"`
	//FSWatcherDelayS         int                         `xml:"fsWatcherDelayS,attr" json:"fsWatcherDelayS" default:"10"`
	//IgnorePerms             bool                        `xml:"ignorePerms,attr" json:"ignorePerms"`
	//AutoNormalize           bool                        `xml:"autoNormalize,attr" json:"autoNormalize" default:"true"`
	//MinDiskFree             Size                        `xml:"minDiskFree" json:"minDiskFree" default:"1%"`
	//Versioning              VersioningConfiguration     `xml:"versioning" json:"versioning"`
	//Copiers                 int                         `xml:"copiers" json:"copiers"` // This defines how many files are handled concurrently.
	//PullerMaxPendingKiB     int                         `xml:"pullerMaxPendingKiB" json:"pullerMaxPendingKiB"`
	//Hashers                 int                         `xml:"hashers" json:"hashers"` // Less than one sets the value to the number of cores. These are CPU bound due to hashing.
	//Order                   PullOrder                   `xml:"order" json:"order"`
	//IgnoreDelete            bool                        `xml:"ignoreDelete" json:"ignoreDelete"`
	//ScanProgressIntervalS   int                         `xml:"scanProgressIntervalS" json:"scanProgressIntervalS"` // Set to a negative value to disable. Value of 0 will get replaced with value of 2 (default value)
	//PullerPauseS            int                         `xml:"pullerPauseS" json:"pullerPauseS"`
	//MaxConflicts            int                         `xml:"maxConflicts" json:"maxConflicts" default:"-1"`
	//DisableSparseFiles      bool                        `xml:"disableSparseFiles" json:"disableSparseFiles"`
	//DisableTempIndexes      bool                        `xml:"disableTempIndexes" json:"disableTempIndexes"`
	//Paused                  bool                        `xml:"paused" json:"paused"`
	//WeakHashThresholdPct    int                         `xml:"weakHashThresholdPct" json:"weakHashThresholdPct"` // Use weak hash if more than X percent of the file has changed. Set to -1 to always use weak hash.
	//MarkerName              string                      `xml:"markerName" json:"markerName"`
	//CopyOwnershipFromParent bool                        `xml:"copyOwnershipFromParent" json:"copyOwnershipFromParent"`
	//RawModTimeWindowS       int                         `xml:"modTimeWindowS" json:"modTimeWindowS"`
	//MaxConcurrentWrites     int                         `xml:"maxConcurrentWrites" json:"maxConcurrentWrites" default:"2"`
	//DisableFsync            bool                        `xml:"disableFsync" json:"disableFsync"`
	//BlockPullOrder          BlockPullOrder              `xml:"blockPullOrder" json:"blockPullOrder"`
	//CopyRangeMethod         fs.CopyRangeMethod          `xml:"copyRangeMethod" json:"copyRangeMethod" default:"standard"`
	//CaseSensitiveFS         bool                        `xml:"caseSensitiveFS" json:"caseSensitiveFS"`
	Id                      string                      `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Label                   string                      `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	FilesystemType          fs.FilesystemType           `protobuf:"varint,3,opt,name=filesystem_type,json=filesystemType,proto3,enum=fs.FilesystemType" json:"filesystem_type,omitempty"`
	Path                    string                      `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	Type                    FolderType                  `protobuf:"varint,5,opt,name=type,proto3,enum=config.FolderType" json:"type,omitempty"`
	Devices                 []FolderDeviceConfiguration `protobuf:"bytes,6,rep,name=devices,proto3" json:"devices"`
	RescanIntervalS         int32                       `protobuf:"varint,7,opt,name=rescan_interval_s,json=rescanIntervalS,proto3" json:"rescan_interval_s,omitempty"`
	FsWatcherEnabled        bool                        `protobuf:"varint,8,opt,name=fs_watcher_enabled,json=fsWatcherEnabled,proto3" json:"fs_watcher_enabled,omitempty"`
	FsWatcherDelay          int32                       `protobuf:"varint,9,opt,name=fs_watcher_delay,json=fsWatcherDelay,proto3" json:"fs_watcher_delay,omitempty"`
	IgnorePerms             bool                        `protobuf:"varint,10,opt,name=ignore_perms,json=ignorePerms,proto3" json:"ignore_perms,omitempty"`
	AutoNormalize           bool                        `protobuf:"varint,11,opt,name=auto_normalize,json=autoNormalize,proto3" json:"auto_normalize,omitempty"`
	MinDiskFree             Size                        `protobuf:"bytes,12,opt,name=min_disk_free,json=minDiskFree,proto3" json:"min_disk_free"`
	Versioning              VersioningConfiguration     `protobuf:"bytes,13,opt,name=versioning,proto3" json:"versioning"`
	Copiers                 int32                       `protobuf:"varint,14,opt,name=copiers,proto3" json:"copiers,omitempty"`
	PullerMaxPendingKib     int32                       `protobuf:"varint,15,opt,name=puller_max_pending_kib,json=pullerMaxPendingKib,proto3" json:"puller_max_pending_kib,omitempty"`
	Hashers                 int32                       `protobuf:"varint,16,opt,name=hashers,proto3" json:"hashers,omitempty"`
	Order                   PullOrder                   `protobuf:"varint,17,opt,name=order,proto3,enum=config.PullOrder" json:"order,omitempty"`
	IgnoreDelete            bool                        `protobuf:"varint,18,opt,name=ignore_delete,json=ignoreDelete,proto3" json:"ignore_delete,omitempty"`
	ScanProgressIntervalS   int32                       `protobuf:"varint,19,opt,name=scan_progress_interval_s,json=scanProgressIntervalS,proto3" json:"scan_progress_interval_s,omitempty"`
	PullerPauseS            int32                       `protobuf:"varint,20,opt,name=puller_pause_s,json=pullerPauseS,proto3" json:"puller_pause_s,omitempty"`
	MaxConflicts            int32                       `protobuf:"varint,21,opt,name=max_conflicts,json=maxConflicts,proto3" json:"max_conflicts,omitempty"`
	DisableSparseFiles      bool                        `protobuf:"varint,22,opt,name=disable_sparse_files,json=disableSparseFiles,proto3" json:"disable_sparse_files,omitempty"`
	DisableTempIndexes      bool                        `protobuf:"varint,23,opt,name=disable_temp_indexes,json=disableTempIndexes,proto3" json:"disable_temp_indexes,omitempty"`
	Paused                  bool                        `protobuf:"varint,24,opt,name=paused,proto3" json:"paused,omitempty"`
	WeakHashThresholdPct    int32                       `protobuf:"varint,25,opt,name=weak_hash_threshold_pct,json=weakHashThresholdPct,proto3" json:"weak_hash_threshold_pct,omitempty"`
	MarkerName              string                      `protobuf:"bytes,26,opt,name=marker_name,json=markerName,proto3" json:"marker_name,omitempty"`
	CopyOwnershipFromParent bool                        `protobuf:"varint,27,opt,name=copy_ownership_from_parent,json=copyOwnershipFromParent,proto3" json:"copy_ownership_from_parent,omitempty"`
	ModTimeWindowS          int32                       `protobuf:"varint,28,opt,name=mod_time_window_s,json=modTimeWindowS,proto3" json:"mod_time_window_s,omitempty"`
	MaxConcurrentWrites     int32                       `protobuf:"varint,29,opt,name=max_concurrent_writes,json=maxConcurrentWrites,proto3" json:"max_concurrent_writes,omitempty"`
	DisableFsync            bool                        `protobuf:"varint,30,opt,name=disable_fsync,json=disableFsync,proto3" json:"disable_fsync,omitempty"`
	BlockPullOrder          BlockPullOrder              `protobuf:"varint,31,opt,name=block_pull_order,json=blockPullOrder,proto3,enum=config.BlockPullOrder" json:"block_pull_order,omitempty"`
	CopyRangeMethod         fs.CopyRangeMethod          `protobuf:"varint,32,opt,name=copy_range_method,json=copyRangeMethod,proto3,enum=fs.CopyRangeMethod" json:"copy_range_method,omitempty"`
	CaseSensitiveFs         bool                        `protobuf:"varint,33,opt,name=case_sensitive_fs,json=caseSensitiveFs,proto3" json:"case_sensitive_fs,omitempty"`
}

func (m *FolderConfiguration) Reset()         { *m = FolderConfiguration{} }
func (m *FolderConfiguration) String() string { return proto.CompactTextString(m) }
func (*FolderConfiguration) ProtoMessage()    {}
func (*FolderConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b3c31ccb4dec1d6, []int{1}
}
func (m *FolderConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FolderConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FolderConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FolderConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FolderConfiguration.Merge(m, src)
}
func (m *FolderConfiguration) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FolderConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_FolderConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_FolderConfiguration proto.InternalMessageInfo

func init() {
	proto.RegisterType((*FolderDeviceConfiguration)(nil), "config.FolderDeviceConfiguration")
	proto.RegisterType((*FolderConfiguration)(nil), "config.FolderConfiguration")
}

func init() { proto.RegisterFile("folderconfiguration.proto", fileDescriptor_6b3c31ccb4dec1d6) }

var fileDescriptor_6b3c31ccb4dec1d6 = []byte{
	// 985 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x55, 0xcd, 0x52, 0x1b, 0x47,
	0x10, 0x96, 0x6c, 0xc0, 0xf6, 0x08, 0x24, 0x18, 0x30, 0x0c, 0xd8, 0x5e, 0x84, 0x9d, 0x1f, 0x25,
	0x95, 0x82, 0x14, 0xae, 0x24, 0x07, 0x1f, 0x92, 0x00, 0x56, 0xc5, 0x95, 0xb2, 0xad, 0x92, 0xa8,
	0x70, 0x9c, 0x1a, 0xed, 0xf6, 0x4a, 0x53, 0xda, 0x9d, 0xd9, 0x9a, 0x59, 0x21, 0xc4, 0x53, 0xe4,
	0x11, 0xf2, 0x2e, 0xb9, 0x70, 0xe4, 0x98, 0x53, 0x2a, 0x86, 0x4b, 0x1e, 0x23, 0x35, 0x3d, 0xbb,
	0x80, 0x52, 0xdc, 0xa6, 0xbf, 0xaf, 0xbb, 0xa7, 0xbb, 0xf7, 0x9b, 0x5e, 0xb2, 0x19, 0xeb, 0x24,
	0x02, 0x13, 0x6a, 0x15, 0xcb, 0xc1, 0xd8, 0x88, 0x5c, 0x6a, 0xb5, 0x9b, 0x19, 0x9d, 0x6b, 0xba,
	0xe0, 0xc1, 0xad, 0x57, 0x06, 0x32, 0x6d, 0xf7, 0x10, 0xec, 0x8f, 0xe3, 0xbd, 0x81, 0x1e, 0x68,
	0x34, 0xf0, 0xe4, 0x9d, 0xb7, 0x68, 0x22, 0xfb, 0x7b, 0xb1, 0xdd, 0xcb, 0xa7, 0x19, 0xd8, 0x02,
	0x7b, 0x5e, 0x60, 0xa1, 0xce, 0xa6, 0x46, 0xa8, 0x01, 0xa4, 0x90, 0x0f, 0x75, 0x54, 0xb0, 0xcb,
	0xfe, 0x66, 0x17, 0x50, 0x20, 0xc4, 0xca, 0xf3, 0xf2, 0xdc, 0xc8, 0xc6, 0x49, 0xa2, 0x4d, 0x04,
	0xa6, 0x00, 0x5e, 0x9c, 0x82, 0xb1, 0x52, 0x2b, 0xa9, 0x06, 0xf7, 0x14, 0xbb, 0xb5, 0xd6, 0x4f,
	0x74, 0x38, 0xfa, 0x5f, 0xd0, 0xcb, 0x67, 0x64, 0xb3, 0x8d, 0xb7, 0x1c, 0xc1, 0xa9, 0x0c, 0xe1,
	0xf0, 0x6e, 0xe0, 0xcb, 0x3f, 0x6b, 0x64, 0xd5, 0xb3, 0x33, 0x38, 0xad, 0x93, 0x07, 0x32, 0x62,
	0xd5, 0x66, 0xb5, 0xf5, 0xa4, 0xfb, 0x40, 0x46, 0x74, 0x8d, 0xcc, 0x27, 0xa2, 0x0f, 0x09, 0x7b,
	0x80, 0x90, 0x37, 0xe8, 0x1b, 0xd2, 0x88, 0x65, 0x02, 0x76, 0x6a, 0x73, 0x48, 0xb9, 0xeb, 0x82,
	0x3d, 0x6c, 0x56, 0x5b, 0xf5, 0x7d, 0xba, 0x1b, 0xdb, 0xdd, 0xf6, 0x0d, 0x75, 0x3c, 0xcd, 0xa0,
	0x5b, 0x8f, 0x67, 0x6c, 0x4a, 0xc9, 0x5c, 0x26, 0xf2, 0x21, 0x9b, 0xc3, 0x8c, 0x78, 0xa6, 0x5f,
	0x90, 0x39, 0xcc, 0x32, 0x5f, 0x64, 0xf1, 0x5d, 0xee, 0xfa, 0x0a, 0x31, 0x0b, 0xf2, 0xf4, 0x67,
	0xf2, 0x28, 0xc2, 0x6e, 0x2c, 0x5b, 0x68, 0x3e, 0x6c, 0xd5, 0xf6, 0x77, 0x66, 0x5d, 0xef, 0x69,
	0xf5, 0x60, 0xee, 0xe2, 0xef, 0xed, 0x4a, 0xb7, 0x8c, 0xa3, 0x5f, 0x93, 0x15, 0x03, 0x36, 0x14,
	0x8a, 0x4b, 0x95, 0x83, 0x39, 0x15, 0x09, 0xb7, 0xec, 0x51, 0xb3, 0xda, 0x9a, 0xef, 0x36, 0x3c,
	0xf1, 0xae, 0xc0, 0x7b, 0xf4, 0x1b, 0x42, 0x63, 0xcb, 0x27, 0x22, 0x0f, 0x87, 0x60, 0x38, 0x28,
	0xd1, 0x4f, 0x20, 0x62, 0x8f, 0x9b, 0xd5, 0xd6, 0xe3, 0xee, 0x72, 0x6c, 0x4f, 0x3c, 0xf1, 0xd6,
	0xe3, 0xb4, 0x45, 0x96, 0xef, 0x78, 0x47, 0x90, 0x88, 0x29, 0x7b, 0x82, 0x89, 0xeb, 0x37, 0xbe,
	0x47, 0x0e, 0xa5, 0x3b, 0x64, 0x51, 0x0e, 0x94, 0x36, 0xc0, 0x33, 0x30, 0xa9, 0x65, 0x04, 0x33,
	0xd6, 0x3c, 0xd6, 0x71, 0x10, 0xfd, 0x9c, 0xd4, 0xc5, 0x38, 0xd7, 0x5c, 0x69, 0x93, 0x8a, 0x44,
	0x9e, 0x03, 0xab, 0xa1, 0xd3, 0x92, 0x43, 0x3f, 0x94, 0x20, 0xfd, 0x9e, 0x2c, 0xa5, 0x52, 0xf1,
	0x48, 0xda, 0x11, 0x8f, 0x0d, 0x00, 0x5b, 0x6c, 0x56, 0x5b, 0xb5, 0xfd, 0xc5, 0x72, 0x2c, 0x3d,
	0x79, 0x0e, 0xc5, 0x04, 0x6a, 0xa9, 0x54, 0x47, 0xd2, 0x8e, 0xda, 0x06, 0x80, 0xbe, 0x25, 0xe4,
	0x56, 0x53, 0x6c, 0x09, 0x83, 0xb6, 0xcb, 0xa0, 0xdf, 0x6e, 0x98, 0xfb, 0x26, 0x79, 0x27, 0x90,
	0x32, 0xf2, 0x28, 0xd4, 0x99, 0x04, 0x63, 0x59, 0x1d, 0x3b, 0x2d, 0x4d, 0xfa, 0x9a, 0xac, 0x3b,
	0x41, 0x82, 0xe1, 0xa9, 0x38, 0xe3, 0x19, 0xa8, 0x48, 0xaa, 0x01, 0x1f, 0xc9, 0x3e, 0x6b, 0xa0,
	0xe3, 0xaa, 0x67, 0xdf, 0x8b, 0xb3, 0x8e, 0xe7, 0x7e, 0x95, 0x7d, 0x97, 0x6e, 0x28, 0xec, 0xd0,
	0xa5, 0x5b, 0xf6, 0xe9, 0x0a, 0x93, 0x7e, 0x49, 0xe6, 0x51, 0xdb, 0x6c, 0x05, 0x15, 0xb2, 0x52,
	0x96, 0xda, 0x19, 0x27, 0xc9, 0x47, 0x47, 0x74, 0x3d, 0x4f, 0x5f, 0x91, 0xa5, 0x62, 0xb4, 0x11,
	0x24, 0x90, 0x03, 0xa3, 0x38, 0xb6, 0x62, 0xde, 0x47, 0x88, 0xd1, 0x1f, 0x08, 0x43, 0x05, 0x64,
	0x46, 0x0f, 0x0c, 0x58, 0x7b, 0x57, 0x0a, 0xab, 0x78, 0xf1, 0x53, 0xc7, 0x77, 0x0a, 0xfa, 0x56,
	0x10, 0x9f, 0x91, 0x7a, 0xd1, 0x55, 0x26, 0xc6, 0x16, 0xb8, 0x65, 0x6b, 0xe8, 0xbe, 0xe8, 0xd1,
	0x8e, 0x03, 0x7b, 0xae, 0x06, 0xd7, 0xb4, 0x2b, 0x31, 0x91, 0x61, 0x6e, 0xd9, 0x53, 0xef, 0x94,
	0x8a, 0xb3, 0xc3, 0x12, 0xa3, 0xdf, 0x92, 0xb5, 0x48, 0x5a, 0xa7, 0x1c, 0x6e, 0x33, 0x61, 0x2c,
	0x70, 0x7c, 0x27, 0x6c, 0x1d, 0xeb, 0xa5, 0x05, 0xd7, 0x43, 0x0a, 0x5f, 0xd4, 0xdd, 0x88, 0x1c,
	0xd2, 0x8c, 0x4b, 0x15, 0xc1, 0x19, 0x58, 0xb6, 0x31, 0x13, 0x71, 0x0c, 0x69, 0xf6, 0xce, 0x33,
	0x74, 0x9d, 0x2c, 0x60, 0x9d, 0x11, 0x63, 0xe8, 0x53, 0x58, 0xf4, 0x3b, 0xb2, 0x31, 0x01, 0x31,
	0xe2, 0x6e, 0xba, 0x3c, 0x1f, 0x1a, 0xb0, 0x43, 0x9d, 0x44, 0x3c, 0x0b, 0x73, 0xb6, 0x89, 0xa5,
	0xae, 0x39, 0xfa, 0x17, 0x61, 0x87, 0xc7, 0x25, 0xd9, 0x09, 0x73, 0xba, 0x4d, 0x6a, 0xa9, 0x30,
	0x23, 0x30, 0x5c, 0x89, 0x14, 0xd8, 0x16, 0x3e, 0x60, 0xe2, 0xa1, 0x0f, 0x22, 0x05, 0xfa, 0x86,
	0x6c, 0xb9, 0x7d, 0xc7, 0xf5, 0x44, 0x81, 0xb1, 0x43, 0x99, 0xf1, 0xd8, 0xe8, 0x94, 0x67, 0xc2,
	0x80, 0xca, 0xd9, 0x33, 0xac, 0x61, 0xc3, 0x79, 0x7c, 0x2c, 0x1d, 0xda, 0x46, 0xa7, 0x1d, 0xa4,
	0xe9, 0x57, 0x64, 0x25, 0xd5, 0x11, 0xcf, 0x65, 0x0a, 0x7c, 0x22, 0x55, 0xa4, 0x27, 0xdc, 0xb2,
	0xe7, 0xfe, 0xfd, 0xa4, 0x3a, 0x3a, 0x96, 0x29, 0x9c, 0x20, 0xdc, 0xa3, 0xfb, 0xe4, 0x69, 0x31,
	0xe0, 0x70, 0x6c, 0x5c, 0x30, 0x9f, 0x18, 0x99, 0x83, 0x65, 0x2f, 0xbc, 0xb6, 0xfc, 0xa0, 0x0b,
	0xee, 0x04, 0x29, 0xf7, 0x51, 0xca, 0xe9, 0xc5, 0x76, 0xaa, 0x42, 0x16, 0x78, 0x61, 0x14, 0x60,
	0xdb, 0x61, 0xf4, 0x27, 0xb2, 0x8c, 0xbb, 0x94, 0xbb, 0xef, 0xc9, 0xbd, 0xe2, 0xb6, 0x51, 0x71,
	0xeb, 0xa5, 0xe2, 0x0e, 0x1c, 0x7f, 0x2b, 0xbb, 0x7a, 0x7f, 0xc6, 0xa6, 0x3f, 0x92, 0x15, 0x1c,
	0x01, 0xee, 0x7c, 0xee, 0x97, 0x3e, 0x6b, 0x62, 0x8a, 0x55, 0xb7, 0x1c, 0x0f, 0x75, 0x36, 0xed,
	0x3a, 0xee, 0x3d, 0x52, 0xdd, 0x46, 0x38, 0x0b, 0xb8, 0xfd, 0x14, 0x0a, 0x27, 0x2d, 0x50, 0x56,
	0xe6, 0xf2, 0xd4, 0x95, 0xcb, 0x76, 0xb0, 0xd6, 0x86, 0x23, 0x7a, 0x25, 0xde, 0xb6, 0x07, 0xad,
	0x8b, 0x4f, 0x41, 0xe5, 0xf2, 0x53, 0x50, 0xb9, 0xb8, 0x0a, 0xaa, 0x97, 0x57, 0x41, 0xf5, 0x9f,
	0xab, 0xa0, 0xf2, 0xef, 0x55, 0x50, 0xfd, 0xfd, 0x3a, 0xa8, 0xfc, 0x71, 0x1d, 0x54, 0x2f, 0xaf,
	0x83, 0xca, 0x5f, 0xd7, 0x41, 0xa5, 0xbf, 0x80, 0xff, 0x84, 0xd7, 0xff, 0x05, 0x00, 0x00, 0xff,
	0xff, 0xd8, 0x6f, 0xdf, 0x71, 0xf3, 0x06, 0x00, 0x00,
}

func (m *FolderDeviceConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FolderDeviceConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FolderDeviceConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FolderConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FolderConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FolderConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CaseSensitiveFs {
		i--
		if m.CaseSensitiveFs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.CopyRangeMethod != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.CopyRangeMethod))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.BlockPullOrder != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.BlockPullOrder))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.DisableFsync {
		i--
		if m.DisableFsync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.MaxConcurrentWrites != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.MaxConcurrentWrites))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.ModTimeWindowS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.ModTimeWindowS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.CopyOwnershipFromParent {
		i--
		if m.CopyOwnershipFromParent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.MarkerName) > 0 {
		i -= len(m.MarkerName)
		copy(dAtA[i:], m.MarkerName)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.MarkerName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.WeakHashThresholdPct != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.WeakHashThresholdPct))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.DisableTempIndexes {
		i--
		if m.DisableTempIndexes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.DisableSparseFiles {
		i--
		if m.DisableSparseFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.MaxConflicts != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.MaxConflicts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.PullerPauseS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.PullerPauseS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ScanProgressIntervalS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.ScanProgressIntervalS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.IgnoreDelete {
		i--
		if m.IgnoreDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Order != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Hashers != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.Hashers))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PullerMaxPendingKib != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.PullerMaxPendingKib))
		i--
		dAtA[i] = 0x78
	}
	if m.Copiers != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.Copiers))
		i--
		dAtA[i] = 0x70
	}
	{
		size, err := m.Versioning.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.MinDiskFree.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.AutoNormalize {
		i--
		if m.AutoNormalize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IgnorePerms {
		i--
		if m.IgnorePerms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.FsWatcherDelay != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.FsWatcherDelay))
		i--
		dAtA[i] = 0x48
	}
	if m.FsWatcherEnabled {
		i--
		if m.FsWatcherEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RescanIntervalS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.RescanIntervalS))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Type != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x22
	}
	if m.FilesystemType != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.FilesystemType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFolderconfiguration(dAtA []byte, offset int, v uint64) int {
	offset -= sovFolderconfiguration(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FolderDeviceConfiguration) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FolderConfiguration) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFolderconfiguration(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovFolderconfiguration(uint64(l))
	}
	if m.FilesystemType != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.FilesystemType))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovFolderconfiguration(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.Type))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.ProtoSize()
			n += 1 + l + sovFolderconfiguration(uint64(l))
		}
	}
	if m.RescanIntervalS != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.RescanIntervalS))
	}
	if m.FsWatcherEnabled {
		n += 2
	}
	if m.FsWatcherDelay != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.FsWatcherDelay))
	}
	if m.IgnorePerms {
		n += 2
	}
	if m.AutoNormalize {
		n += 2
	}
	l = m.MinDiskFree.ProtoSize()
	n += 1 + l + sovFolderconfiguration(uint64(l))
	l = m.Versioning.ProtoSize()
	n += 1 + l + sovFolderconfiguration(uint64(l))
	if m.Copiers != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.Copiers))
	}
	if m.PullerMaxPendingKib != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.PullerMaxPendingKib))
	}
	if m.Hashers != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.Hashers))
	}
	if m.Order != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.Order))
	}
	if m.IgnoreDelete {
		n += 3
	}
	if m.ScanProgressIntervalS != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.ScanProgressIntervalS))
	}
	if m.PullerPauseS != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.PullerPauseS))
	}
	if m.MaxConflicts != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.MaxConflicts))
	}
	if m.DisableSparseFiles {
		n += 3
	}
	if m.DisableTempIndexes {
		n += 3
	}
	if m.Paused {
		n += 3
	}
	if m.WeakHashThresholdPct != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.WeakHashThresholdPct))
	}
	l = len(m.MarkerName)
	if l > 0 {
		n += 2 + l + sovFolderconfiguration(uint64(l))
	}
	if m.CopyOwnershipFromParent {
		n += 3
	}
	if m.ModTimeWindowS != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.ModTimeWindowS))
	}
	if m.MaxConcurrentWrites != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.MaxConcurrentWrites))
	}
	if m.DisableFsync {
		n += 3
	}
	if m.BlockPullOrder != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.BlockPullOrder))
	}
	if m.CopyRangeMethod != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.CopyRangeMethod))
	}
	if m.CaseSensitiveFs {
		n += 3
	}
	return n
}

func sovFolderconfiguration(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFolderconfiguration(x uint64) (n int) {
	return sovFolderconfiguration(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FolderDeviceConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFolderconfiguration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FolderDeviceConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FolderDeviceConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFolderconfiguration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FolderConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFolderconfiguration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FolderConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FolderConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilesystemType", wireType)
			}
			m.FilesystemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilesystemType |= fs.FilesystemType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FolderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, FolderDeviceConfiguration{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RescanIntervalS", wireType)
			}
			m.RescanIntervalS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RescanIntervalS |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsWatcherEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FsWatcherEnabled = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsWatcherDelay", wireType)
			}
			m.FsWatcherDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FsWatcherDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnorePerms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnorePerms = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoNormalize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoNormalize = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDiskFree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDiskFree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Versioning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Copiers", wireType)
			}
			m.Copiers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Copiers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullerMaxPendingKib", wireType)
			}
			m.PullerMaxPendingKib = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PullerMaxPendingKib |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashers", wireType)
			}
			m.Hashers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hashers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= PullOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreDelete = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanProgressIntervalS", wireType)
			}
			m.ScanProgressIntervalS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanProgressIntervalS |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullerPauseS", wireType)
			}
			m.PullerPauseS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PullerPauseS |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConflicts", wireType)
			}
			m.MaxConflicts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConflicts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableSparseFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableSparseFiles = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableTempIndexes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableTempIndexes = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeakHashThresholdPct", wireType)
			}
			m.WeakHashThresholdPct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeakHashThresholdPct |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarkerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyOwnershipFromParent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyOwnershipFromParent = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTimeWindowS", wireType)
			}
			m.ModTimeWindowS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModTimeWindowS |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConcurrentWrites", wireType)
			}
			m.MaxConcurrentWrites = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConcurrentWrites |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableFsync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableFsync = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPullOrder", wireType)
			}
			m.BlockPullOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockPullOrder |= BlockPullOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyRangeMethod", wireType)
			}
			m.CopyRangeMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyRangeMethod |= fs.CopyRangeMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaseSensitiveFs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CaseSensitiveFs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFolderconfiguration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFolderconfiguration(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFolderconfiguration
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFolderconfiguration
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFolderconfiguration
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFolderconfiguration
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFolderconfiguration        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFolderconfiguration          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFolderconfiguration = fmt.Errorf("proto: unexpected end of group")
)
