// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lib/config/folderconfiguration.proto

package config

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	fs "github.com/syncthing/syncthing/lib/fs"
	github_com_syncthing_syncthing_lib_protocol "github.com/syncthing/syncthing/lib/protocol"
	_ "github.com/syncthing/syncthing/proto/ext"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type FolderDeviceConfiguration struct {
	DeviceID           github_com_syncthing_syncthing_lib_protocol.DeviceID `protobuf:"bytes,1,opt,name=device_id,json=deviceId,proto3,customtype=github.com/syncthing/syncthing/lib/protocol.DeviceID" json:"deviceID" xml:"id,attr"`
	IntroducedBy       github_com_syncthing_syncthing_lib_protocol.DeviceID `protobuf:"bytes,2,opt,name=introduced_by,json=introducedBy,proto3,customtype=github.com/syncthing/syncthing/lib/protocol.DeviceID" json:"introducedBy" xml:"introducedBy,attr"`
	EncryptionPassword string                                               `protobuf:"bytes,3,opt,name=encryption_password,json=encryptionPassword,proto3" json:"encryptionPassword" xml:"encryptionPassword"`
}

func (m *FolderDeviceConfiguration) Reset()         { *m = FolderDeviceConfiguration{} }
func (m *FolderDeviceConfiguration) String() string { return proto.CompactTextString(m) }
func (*FolderDeviceConfiguration) ProtoMessage()    {}
func (*FolderDeviceConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_44a9785876ed3afa, []int{0}
}
func (m *FolderDeviceConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FolderDeviceConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FolderDeviceConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FolderDeviceConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FolderDeviceConfiguration.Merge(m, src)
}
func (m *FolderDeviceConfiguration) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FolderDeviceConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_FolderDeviceConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_FolderDeviceConfiguration proto.InternalMessageInfo

type FolderConfiguration struct {
	ID                      string                      `protobuf:"bytes,1,opt,name=id,proto3" json:"id" xml:"id,attr" nodefault:"true"`
	Label                   string                      `protobuf:"bytes,2,opt,name=label,proto3" json:"label" xml:"label,attr" restart:"false"`
	FilesystemType          fs.FilesystemType           `protobuf:"varint,3,opt,name=filesystem_type,json=filesystemType,proto3,enum=fs.FilesystemType" json:"filesystemType" xml:"filesystemType"`
	Path                    string                      `protobuf:"bytes,4,opt,name=path,proto3" json:"path" xml:"path,attr" default:"~"`
	Type                    FolderType                  `protobuf:"varint,5,opt,name=type,proto3,enum=config.FolderType" json:"type" xml:"type,attr"`
	Devices                 []FolderDeviceConfiguration `protobuf:"bytes,6,rep,name=devices,proto3" json:"devices" xml:"device"`
	RescanIntervalS         int                         `protobuf:"varint,7,opt,name=rescan_interval_s,json=rescanIntervalS,proto3,casttype=int" json:"rescanIntervalS" xml:"rescanIntervalS,attr" default:"3600"`
	FSWatcherEnabled        bool                        `protobuf:"varint,8,opt,name=fs_watcher_enabled,json=fsWatcherEnabled,proto3" json:"fsWatcherEnabled" xml:"fsWatcherEnabled,attr" default:"true"`
	FSWatcherDelayS         int                         `protobuf:"varint,9,opt,name=fs_watcher_delay_s,json=fsWatcherDelayS,proto3,casttype=int" json:"fsWatcherDelayS" xml:"fsWatcherDelayS,attr" default:"10"`
	IgnorePerms             bool                        `protobuf:"varint,10,opt,name=ignore_perms,json=ignorePerms,proto3" json:"ignorePerms" xml:"ignorePerms,attr"`
	AutoNormalize           bool                        `protobuf:"varint,11,opt,name=auto_normalize,json=autoNormalize,proto3" json:"autoNormalize" xml:"autoNormalize,attr" default:"true"`
	MinDiskFree             Size                        `protobuf:"bytes,12,opt,name=min_disk_free,json=minDiskFree,proto3" json:"minDiskFree" xml:"minDiskFree" default:"1 %"`
	Versioning              VersioningConfiguration     `protobuf:"bytes,13,opt,name=versioning,proto3" json:"versioning" xml:"versioning"`
	Copiers                 int                         `protobuf:"varint,14,opt,name=copiers,proto3,casttype=int" json:"copiers" xml:"copiers"`
	PullerMaxPendingKiB     int                         `protobuf:"varint,15,opt,name=puller_max_pending_kib,json=pullerMaxPendingKib,proto3,casttype=int" json:"pullerMaxPendingKiB" xml:"pullerMaxPendingKiB"`
	Hashers                 int                         `protobuf:"varint,16,opt,name=hashers,proto3,casttype=int" json:"hashers" xml:"hashers"`
	Order                   PullOrder                   `protobuf:"varint,17,opt,name=order,proto3,enum=config.PullOrder" json:"order" xml:"order"`
	IgnoreDelete            bool                        `protobuf:"varint,18,opt,name=ignore_delete,json=ignoreDelete,proto3" json:"ignoreDelete" xml:"ignoreDelete"`
	ScanProgressIntervalS   int                         `protobuf:"varint,19,opt,name=scan_progress_interval_s,json=scanProgressIntervalS,proto3,casttype=int" json:"scanProgressIntervalS" xml:"scanProgressIntervalS"`
	PullerPauseS            int                         `protobuf:"varint,20,opt,name=puller_pause_s,json=pullerPauseS,proto3,casttype=int" json:"pullerPauseS" xml:"pullerPauseS"`
	MaxConflicts            int                         `protobuf:"varint,21,opt,name=max_conflicts,json=maxConflicts,proto3,casttype=int" json:"maxConflicts" xml:"maxConflicts" default:"10"`
	DisableSparseFiles      bool                        `protobuf:"varint,22,opt,name=disable_sparse_files,json=disableSparseFiles,proto3" json:"disableSparseFiles" xml:"disableSparseFiles"`
	DisableTempIndexes      bool                        `protobuf:"varint,23,opt,name=disable_temp_indexes,json=disableTempIndexes,proto3" json:"disableTempIndexes" xml:"disableTempIndexes"`
	Paused                  bool                        `protobuf:"varint,24,opt,name=paused,proto3" json:"paused" xml:"paused"`
	WeakHashThresholdPct    int                         `protobuf:"varint,25,opt,name=weak_hash_threshold_pct,json=weakHashThresholdPct,proto3,casttype=int" json:"weakHashThresholdPct" xml:"weakHashThresholdPct"`
	MarkerName              string                      `protobuf:"bytes,26,opt,name=marker_name,json=markerName,proto3" json:"markerName" xml:"markerName"`
	CopyOwnershipFromParent bool                        `protobuf:"varint,27,opt,name=copy_ownership_from_parent,json=copyOwnershipFromParent,proto3" json:"copyOwnershipFromParent" xml:"copyOwnershipFromParent"`
	RawModTimeWindowS       int                         `protobuf:"varint,28,opt,name=mod_time_window_s,json=modTimeWindowS,proto3,casttype=int" json:"modTimeWindowS" xml:"modTimeWindowS"`
	MaxConcurrentWrites     int                         `protobuf:"varint,29,opt,name=max_concurrent_writes,json=maxConcurrentWrites,proto3,casttype=int" json:"maxConcurrentWrites" xml:"maxConcurrentWrites" default:"2"`
	DisableFsync            bool                        `protobuf:"varint,30,opt,name=disable_fsync,json=disableFsync,proto3" json:"disableFsync" xml:"disableFsync"`
	BlockPullOrder          BlockPullOrder              `protobuf:"varint,31,opt,name=block_pull_order,json=blockPullOrder,proto3,enum=config.BlockPullOrder" json:"blockPullOrder" xml:"blockPullOrder"`
	CopyRangeMethod         fs.CopyRangeMethod          `protobuf:"varint,32,opt,name=copy_range_method,json=copyRangeMethod,proto3,enum=fs.CopyRangeMethod" json:"copyRangeMethod" xml:"copyRangeMethod" default:"standard"`
	CaseSensitiveFS         bool                        `protobuf:"varint,33,opt,name=case_sensitive_fs,json=caseSensitiveFs,proto3" json:"caseSensitiveFS" xml:"caseSensitiveFS"`
	JunctionsAsDirs         bool                        `protobuf:"varint,34,opt,name=follow_junctions,json=followJunctions,proto3" json:"junctionsAsDirs" xml:"junctionsAsDirs"`
	SyncOwnership           bool                        `protobuf:"varint,35,opt,name=sync_ownership,json=syncOwnership,proto3" json:"syncOwnership" xml:"syncOwnership"`
	SyncXattrs              bool                        `protobuf:"varint,36,opt,name=sync_xattrs,json=syncXattrs,proto3" json:"syncXattrs" xml:"syncXattrs"`
	XattrFilter             StringFilter                `protobuf:"bytes,37,opt,name=xattr_filter,json=xattrFilter,proto3" json:"xattrFilter" xml:"xattrFilter"`
	// Legacy deprecated
	DeprecatedReadOnly       bool    `protobuf:"varint,9000,opt,name=read_only,json=readOnly,proto3" json:"-" xml:"ro,attr,omitempty"`                       // Deprecated: Do not use.
	DeprecatedMinDiskFreePct float64 `protobuf:"fixed64,9001,opt,name=min_disk_free_pct,json=minDiskFreePct,proto3" json:"-" xml:"minDiskFreePct,omitempty"` // Deprecated: Do not use.
	DeprecatedPullers        int     `protobuf:"varint,9002,opt,name=pullers,proto3,casttype=int" json:"-" xml:"pullers,omitempty"`                          // Deprecated: Do not use.
}

func (m *FolderConfiguration) Reset()         { *m = FolderConfiguration{} }
func (m *FolderConfiguration) String() string { return proto.CompactTextString(m) }
func (*FolderConfiguration) ProtoMessage()    {}
func (*FolderConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_44a9785876ed3afa, []int{1}
}
func (m *FolderConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FolderConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FolderConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FolderConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FolderConfiguration.Merge(m, src)
}
func (m *FolderConfiguration) XXX_Size() int {
	return m.ProtoSize()
}
func (m *FolderConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_FolderConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_FolderConfiguration proto.InternalMessageInfo

// Generic string filter. This is a list of patterns to match (glob style),
// each with an action (permit or deny). First match is used. If the filter
// is empty, all strings are permitted. If the filter is non-empty, the
// default action becomes deny. To counter this, you can use the "*" pattern
// to match all strings at the end of the filter.
type StringFilter struct {
	Entries []StringFilterEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries" xml:"entry"`
}

func (m *StringFilter) Reset()         { *m = StringFilter{} }
func (m *StringFilter) String() string { return proto.CompactTextString(m) }
func (*StringFilter) ProtoMessage()    {}
func (*StringFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_44a9785876ed3afa, []int{2}
}
func (m *StringFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringFilter.Merge(m, src)
}
func (m *StringFilter) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StringFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_StringFilter.DiscardUnknown(m)
}

var xxx_messageInfo_StringFilter proto.InternalMessageInfo

type StringFilterEntry struct {
	Match  string `protobuf:"bytes,1,opt,name=match,proto3" json:"match" xml:",attr"`
	Permit bool   `protobuf:"varint,2,opt,name=permit,proto3" json:"permit" xml:",attr"`
}

func (m *StringFilterEntry) Reset()         { *m = StringFilterEntry{} }
func (m *StringFilterEntry) String() string { return proto.CompactTextString(m) }
func (*StringFilterEntry) ProtoMessage()    {}
func (*StringFilterEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_44a9785876ed3afa, []int{3}
}
func (m *StringFilterEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringFilterEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringFilterEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StringFilterEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringFilterEntry.Merge(m, src)
}
func (m *StringFilterEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StringFilterEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_StringFilterEntry.DiscardUnknown(m)
}

var xxx_messageInfo_StringFilterEntry proto.InternalMessageInfo

func init() {
	proto.RegisterType((*FolderDeviceConfiguration)(nil), "config.FolderDeviceConfiguration")
	proto.RegisterType((*FolderConfiguration)(nil), "config.FolderConfiguration")
	proto.RegisterType((*StringFilter)(nil), "config.StringFilter")
	proto.RegisterType((*StringFilterEntry)(nil), "config.StringFilterEntry")
}

func init() {
	proto.RegisterFile("lib/config/folderconfiguration.proto", fileDescriptor_44a9785876ed3afa)
}

var fileDescriptor_44a9785876ed3afa = []byte{
	// 2230 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xcf, 0x6f, 0xdc, 0xc6,
	0xf5, 0x17, 0x65, 0xcb, 0x96, 0x46, 0xbf, 0x47, 0x92, 0x3d, 0x96, 0x13, 0x8d, 0xcc, 0xac, 0x13,
	0x25, 0x48, 0x64, 0x5b, 0xf9, 0xe2, 0x5b, 0xd4, 0xa8, 0xdb, 0x66, 0x25, 0x0b, 0x75, 0x5d, 0xc5,
	0x02, 0xe5, 0xd6, 0x6d, 0x5a, 0x80, 0xa5, 0xc8, 0xd9, 0x15, 0x23, 0xfe, 0xd8, 0xce, 0x50, 0x96,
	0xd6, 0x87, 0xc0, 0xbd, 0x14, 0x29, 0x9a, 0x43, 0xa1, 0x1e, 0x72, 0x0d, 0xd0, 0xa2, 0x68, 0xf3,
	0x0f, 0x14, 0xe8, 0x5f, 0xe0, 0x4b, 0xa1, 0x3d, 0x15, 0x45, 0x0f, 0x03, 0x44, 0xbe, 0xed, 0x91,
	0x47, 0x9f, 0x8a, 0x79, 0x43, 0x72, 0xc9, 0xdd, 0x35, 0x50, 0xa0, 0x37, 0xce, 0xe7, 0xf3, 0xe6,
	0xbd, 0x37, 0x6f, 0xde, 0xbc, 0x79, 0x43, 0x54, 0x0b, 0xfc, 0xfd, 0x5b, 0x6e, 0x1c, 0x35, 0xfc,
	0xe6, 0xad, 0x46, 0x1c, 0x78, 0x8c, 0xeb, 0xc1, 0x11, 0x77, 0x12, 0x3f, 0x8e, 0xd6, 0x5b, 0x3c,
	0x4e, 0x62, 0x7c, 0x49, 0x83, 0xcb, 0xd7, 0x07, 0xa4, 0x93, 0x76, 0x8b, 0x69, 0xa1, 0xe5, 0xa5,
	0x12, 0x29, 0xfc, 0x67, 0x39, 0xbc, 0x5c, 0x82, 0x5b, 0x47, 0x41, 0x10, 0x73, 0x8f, 0xf1, 0x8c,
	0x5b, 0x2b, 0x71, 0x4f, 0x19, 0x17, 0x7e, 0x1c, 0xf9, 0x51, 0x73, 0x88, 0x07, 0xcb, 0xb4, 0x24,
	0xb9, 0x1f, 0xc4, 0xee, 0x61, 0xbf, 0x2a, 0xac, 0x04, 0x1a, 0xe2, 0x96, 0x72, 0x48, 0x64, 0xd8,
	0x1b, 0x19, 0xe6, 0xc6, 0xad, 0x36, 0x77, 0xa2, 0x26, 0x0b, 0x59, 0x72, 0x10, 0x7b, 0x19, 0x3b,
	0xc1, 0x4e, 0x12, 0xfd, 0x69, 0xfe, 0xf3, 0x02, 0xba, 0xb6, 0x0d, 0xeb, 0xd9, 0x62, 0x4f, 0x7d,
	0x97, 0x6d, 0x96, 0x3d, 0xc0, 0x5f, 0x1b, 0x68, 0xc2, 0x03, 0xdc, 0xf6, 0x3d, 0x62, 0xac, 0x1a,
	0x6b, 0x53, 0xf5, 0x2f, 0x8c, 0x17, 0x92, 0x8e, 0xfc, 0x5b, 0xd2, 0xff, 0x6b, 0xfa, 0xc9, 0xc1,
	0xd1, 0xfe, 0xba, 0x1b, 0x87, 0xb7, 0x44, 0x3b, 0x72, 0x93, 0x03, 0x3f, 0x6a, 0x96, 0xbe, 0x94,
	0x0b, 0x60, 0xc4, 0x8d, 0x83, 0x75, 0xad, 0xfd, 0xc1, 0xd6, 0xb9, 0xa4, 0xe3, 0xf9, 0x77, 0x57,
	0xd2, 0x71, 0x2f, 0xfb, 0x4e, 0x25, 0x9d, 0x3e, 0x09, 0x83, 0xbb, 0xa6, 0xef, 0xbd, 0xef, 0x24,
	0x09, 0x37, 0xbb, 0x67, 0xb5, 0xcb, 0xd9, 0x77, 0x7a, 0x56, 0x2b, 0xe4, 0x3e, 0xef, 0xd4, 0x8c,
	0xd3, 0x4e, 0xad, 0xd0, 0x61, 0xe5, 0x8c, 0x87, 0xff, 0x6c, 0xa0, 0x69, 0x3f, 0x4a, 0x78, 0xec,
	0x1d, 0xb9, 0xcc, 0xb3, 0xf7, 0xdb, 0x64, 0x14, 0x1c, 0x7e, 0xfe, 0x3f, 0x39, 0xdc, 0x95, 0x74,
	0xaa, 0xa7, 0xb5, 0xde, 0x4e, 0x25, 0xbd, 0xaa, 0x1d, 0x2d, 0x81, 0x85, 0xcb, 0xf3, 0x03, 0xa8,
	0x72, 0xd8, 0xaa, 0x68, 0xc0, 0x2e, 0x5a, 0x60, 0x91, 0xcb, 0xdb, 0x2d, 0x15, 0x63, 0xbb, 0xe5,
	0x08, 0x71, 0x1c, 0x73, 0x8f, 0x5c, 0x58, 0x35, 0xd6, 0x26, 0xea, 0x1b, 0x5d, 0x49, 0x71, 0x8f,
	0xde, 0xcd, 0xd8, 0x54, 0x52, 0x02, 0x66, 0x07, 0x29, 0xd3, 0x1a, 0x22, 0x6f, 0x7e, 0x69, 0xa2,
	0x05, 0xbd, 0xb1, 0xd5, 0x2d, 0xdd, 0x43, 0xa3, 0xd9, 0x56, 0x4e, 0xd4, 0x37, 0xcf, 0x25, 0x1d,
	0x85, 0x25, 0x8e, 0xfa, 0xca, 0xc2, 0x4a, 0x65, 0x07, 0x56, 0xa3, 0xd8, 0x63, 0x0d, 0xe7, 0x28,
	0x48, 0xee, 0x9a, 0x09, 0x3f, 0x62, 0xe5, 0x2d, 0x39, 0xed, 0xd4, 0x46, 0x1f, 0x6c, 0x7d, 0xa5,
	0xd6, 0x36, 0xea, 0x7b, 0xf8, 0xc7, 0x68, 0x2c, 0x70, 0xf6, 0x59, 0x00, 0x11, 0x9f, 0xa8, 0x7f,
	0xaf, 0x2b, 0xa9, 0x06, 0x52, 0x49, 0x57, 0x41, 0x29, 0x8c, 0x32, 0xbd, 0x9c, 0x89, 0xc4, 0xe1,
	0xc9, 0x5d, 0xb3, 0xe1, 0x04, 0x02, 0xd4, 0xa2, 0x1e, 0xfd, 0xbc, 0x53, 0x1b, 0xb1, 0xf4, 0x64,
	0xdc, 0x44, 0xb3, 0x0d, 0x3f, 0x60, 0xa2, 0x2d, 0x12, 0x16, 0xda, 0x2a, 0xbf, 0x21, 0x48, 0x33,
	0x1b, 0x78, 0xbd, 0x21, 0xd6, 0xb7, 0x0b, 0xea, 0x71, 0xbb, 0xc5, 0xea, 0xef, 0x75, 0x25, 0x9d,
	0x69, 0x54, 0xb0, 0x54, 0xd2, 0x45, 0xb0, 0x5e, 0x85, 0x4d, 0xab, 0x4f, 0x0e, 0xef, 0xa0, 0x8b,
	0x2d, 0x27, 0x39, 0x20, 0x17, 0xc1, 0xfd, 0x6f, 0x77, 0x25, 0x85, 0x71, 0x2a, 0xe9, 0x75, 0x98,
	0xaf, 0x06, 0x99, 0xf3, 0x45, 0x48, 0x3e, 0x53, 0x8e, 0x4f, 0x14, 0xcc, 0xab, 0xb3, 0x9a, 0xf1,
	0x99, 0x05, 0xd3, 0xf0, 0x2e, 0xba, 0x08, 0xce, 0x8e, 0x65, 0xce, 0xea, 0xd3, 0xbb, 0xae, 0xb7,
	0x03, 0x9c, 0x5d, 0x53, 0x26, 0x12, 0xed, 0xe2, 0x2c, 0x98, 0x50, 0x83, 0x22, 0x8d, 0x26, 0x8a,
	0x91, 0x05, 0x52, 0xf8, 0x17, 0xe8, 0xb2, 0xce, 0x73, 0x41, 0x2e, 0xad, 0x5e, 0x58, 0x9b, 0xdc,
	0xb8, 0x51, 0x55, 0x3a, 0xe4, 0xf0, 0xd6, 0xa9, 0x4a, 0xfb, 0xae, 0xa4, 0xf9, 0xcc, 0x54, 0xd2,
	0x29, 0x30, 0xa5, 0xc7, 0xa6, 0x95, 0x13, 0xf8, 0x0f, 0x06, 0x9a, 0xe7, 0x4c, 0xb8, 0x4e, 0x64,
	0xfb, 0x51, 0xc2, 0xf8, 0x53, 0x27, 0xb0, 0x05, 0xb9, 0xbc, 0x6a, 0xac, 0x8d, 0xd5, 0x9b, 0x5d,
	0x49, 0x67, 0x35, 0xf9, 0x20, 0xe3, 0xf6, 0x52, 0x49, 0xdf, 0x05, 0x4d, 0x7d, 0x78, 0x7f, 0x88,
	0x3e, 0xfc, 0xff, 0xdb, 0xb7, 0xcd, 0x57, 0x92, 0x5e, 0xf0, 0xa3, 0xa4, 0x7b, 0x56, 0x5b, 0x1c,
	0x26, 0xfe, 0xea, 0xac, 0x76, 0x51, 0xc9, 0x59, 0xfd, 0x46, 0xf0, 0xdf, 0x0d, 0x84, 0x1b, 0xc2,
	0x3e, 0x76, 0x12, 0xf7, 0x80, 0x71, 0x9b, 0x45, 0xce, 0x7e, 0xc0, 0x3c, 0x32, 0xbe, 0x6a, 0xac,
	0x8d, 0xd7, 0x7f, 0x67, 0x9c, 0x4b, 0x3a, 0xb7, 0xbd, 0xf7, 0x44, 0xb3, 0xf7, 0x35, 0xd9, 0x95,
	0x74, 0xae, 0x21, 0xaa, 0x58, 0x2a, 0xe9, 0x7b, 0x3a, 0x09, 0xfa, 0x88, 0x7e, 0x6f, 0xf3, 0x1c,
	0x5f, 0x1a, 0x2a, 0xa8, 0xfc, 0x54, 0x12, 0xa7, 0x9d, 0xda, 0x80, 0x59, 0x6b, 0xc0, 0x28, 0xfe,
	0x5b, 0xd5, 0x79, 0x8f, 0x05, 0x4e, 0xdb, 0x16, 0x64, 0x02, 0x62, 0xfa, 0x5b, 0xe5, 0xfc, 0x6c,
	0xa1, 0x65, 0x4b, 0x91, 0x7b, 0x2a, 0xce, 0x85, 0x1a, 0x0d, 0xa5, 0x92, 0xbe, 0x53, 0x75, 0x5d,
	0xe3, 0xfd, 0x9e, 0xdf, 0xa9, 0x44, 0x79, 0x98, 0xf0, 0xab, 0xb3, 0xda, 0xe8, 0x9d, 0xdb, 0xa7,
	0x9d, 0x5a, 0xbf, 0x55, 0xab, 0xdf, 0x26, 0xfe, 0x25, 0x9a, 0xf2, 0x9b, 0x51, 0xcc, 0x99, 0xdd,
	0x62, 0x3c, 0x14, 0x04, 0x41, 0xbc, 0xef, 0x75, 0x25, 0x9d, 0xd4, 0xf8, 0xae, 0x82, 0x53, 0x49,
	0xaf, 0xe8, 0x6a, 0xd1, 0xc3, 0x8a, 0xf4, 0x9d, 0xeb, 0x07, 0xad, 0xf2, 0x54, 0xfc, 0x6b, 0x03,
	0xcd, 0x38, 0x47, 0x49, 0x6c, 0x47, 0x31, 0x0f, 0x9d, 0xc0, 0x7f, 0xc6, 0xc8, 0x24, 0x18, 0xf9,
	0xa4, 0x2b, 0xe9, 0xb4, 0x62, 0x3e, 0xce, 0x89, 0x22, 0x02, 0x15, 0xf4, 0x75, 0x3b, 0x87, 0x07,
	0xa5, 0xf2, 0x6d, 0xb3, 0xaa, 0x7a, 0x71, 0x8c, 0xa6, 0x43, 0x3f, 0xb2, 0x3d, 0x5f, 0x1c, 0xda,
	0x0d, 0xce, 0x18, 0x99, 0x5a, 0x35, 0xd6, 0x26, 0x37, 0xa6, 0xf2, 0x63, 0xb5, 0xe7, 0x3f, 0x63,
	0xf5, 0x7b, 0xd9, 0x09, 0x9a, 0x0c, 0xfd, 0x68, 0xcb, 0x17, 0x87, 0xdb, 0x9c, 0x29, 0x8f, 0x28,
	0x78, 0x54, 0xc2, 0xca, 0x5b, 0xb1, 0x7a, 0xd3, 0x7c, 0x75, 0x56, 0xbb, 0x70, 0x67, 0xf5, 0xa6,
	0x55, 0x9e, 0x86, 0x9b, 0x08, 0xf5, 0xee, 0x79, 0x32, 0x0d, 0xd6, 0x68, 0x6e, 0xed, 0x27, 0x05,
	0x53, 0x3d, 0xc2, 0x6f, 0x67, 0x0e, 0x94, 0xa6, 0xa6, 0x92, 0xce, 0x81, 0xfd, 0x1e, 0x64, 0x5a,
	0x25, 0x1e, 0xdf, 0x43, 0x97, 0xdd, 0xb8, 0xe5, 0x33, 0x2e, 0xc8, 0x0c, 0x64, 0xdb, 0x5b, 0xaa,
	0x06, 0x64, 0x50, 0x71, 0xcd, 0x66, 0xe3, 0x3c, 0x6f, 0xac, 0x5c, 0x00, 0xff, 0xc3, 0x40, 0x57,
	0x54, 0x87, 0xc1, 0xb8, 0x1d, 0x3a, 0x27, 0x76, 0x8b, 0x45, 0x9e, 0x1f, 0x35, 0xed, 0x43, 0x7f,
	0x9f, 0xcc, 0x82, 0xba, 0x2f, 0x55, 0xf2, 0x2e, 0xec, 0x82, 0xc8, 0x8e, 0x73, 0xb2, 0xab, 0x05,
	0x1e, 0xfa, 0xf5, 0xae, 0xa4, 0x0b, 0xad, 0x41, 0x38, 0x95, 0xf4, 0x9a, 0x2e, 0xa2, 0x83, 0x5c,
	0x29, 0x6d, 0x87, 0x4e, 0x1d, 0x0e, 0x9f, 0x76, 0x6a, 0xc3, 0xec, 0x5b, 0x43, 0x64, 0xf7, 0x55,
	0x38, 0x0e, 0x1c, 0x71, 0xa0, 0xc2, 0x31, 0xd7, 0x0b, 0x47, 0x06, 0x15, 0xe1, 0xc8, 0xc6, 0xbd,
	0x70, 0x64, 0x00, 0xfe, 0x08, 0x8d, 0x41, 0xaf, 0x45, 0xe6, 0xa1, 0x96, 0xcf, 0xe7, 0x3b, 0xa6,
	0xec, 0x3f, 0x52, 0x44, 0x9d, 0xa8, 0xcb, 0x0e, 0x64, 0x52, 0x49, 0x27, 0x41, 0x1b, 0x8c, 0x4c,
	0x4b, 0xa3, 0xf8, 0x21, 0x9a, 0xce, 0x0e, 0x94, 0xc7, 0x02, 0x96, 0x30, 0x82, 0x21, 0xd9, 0xdf,
	0x86, 0xce, 0x02, 0x88, 0x2d, 0xc0, 0x53, 0x49, 0x71, 0xe9, 0x48, 0x69, 0xd0, 0xb4, 0x2a, 0x32,
	0xf8, 0x04, 0x11, 0xa8, 0xd3, 0x2d, 0x1e, 0x37, 0x39, 0x13, 0xa2, 0x5c, 0xb0, 0x17, 0x60, 0x7d,
	0xea, 0xf2, 0x5d, 0x52, 0x32, 0xbb, 0x99, 0x48, 0xb9, 0x6c, 0xeb, 0xeb, 0x6c, 0x28, 0x5b, 0xac,
	0x7d, 0xf8, 0x64, 0xbc, 0x87, 0x66, 0xb2, 0xbc, 0x68, 0x39, 0x47, 0x82, 0xd9, 0x82, 0x2c, 0x82,
	0xbd, 0x0f, 0xd4, 0x3a, 0x34, 0xb3, 0xab, 0x88, 0xbd, 0x62, 0x1d, 0x65, 0xb0, 0xd0, 0x5e, 0x11,
	0xc5, 0x0c, 0x4d, 0xab, 0x2c, 0x53, 0x41, 0x0d, 0x7c, 0x37, 0x11, 0x64, 0x09, 0x74, 0x7e, 0x5f,
	0xe9, 0x0c, 0x9d, 0x93, 0xcd, 0x1c, 0xef, 0x9d, 0xba, 0x12, 0x38, 0xb4, 0x02, 0xea, 0x4a, 0x67,
	0x55, 0x66, 0x63, 0x0f, 0x2d, 0x7a, 0xbe, 0x50, 0x95, 0xd9, 0x16, 0x2d, 0x87, 0x0b, 0x66, 0x43,
	0x03, 0x40, 0xae, 0xc0, 0x4e, 0x40, 0xcb, 0x95, 0xf1, 0x7b, 0x40, 0x43, 0x6b, 0x51, 0xb4, 0x5c,
	0x83, 0x94, 0x69, 0x0d, 0x91, 0x2f, 0x5b, 0x49, 0x58, 0xd8, 0xb2, 0xfd, 0xc8, 0x63, 0x27, 0x4c,
	0x90, 0xab, 0x03, 0x56, 0x1e, 0xb3, 0xb0, 0xf5, 0x40, 0xb3, 0xfd, 0x56, 0x4a, 0x54, 0xcf, 0x4a,
	0x09, 0xc4, 0x1b, 0xe8, 0x12, 0x6c, 0x80, 0x47, 0x08, 0xe8, 0x5d, 0xee, 0x4a, 0x9a, 0x21, 0xc5,
	0x0d, 0xaf, 0x87, 0xa6, 0x95, 0xe1, 0x38, 0x41, 0x57, 0x8f, 0x99, 0x73, 0x68, 0xab, 0xac, 0xb6,
	0x93, 0x03, 0xce, 0xc4, 0x41, 0x1c, 0x78, 0x76, 0xcb, 0x4d, 0xc8, 0x35, 0x08, 0xb8, 0x2a, 0xef,
	0x8b, 0x4a, 0xe4, 0x07, 0x8e, 0x38, 0x78, 0x9c, 0x0b, 0xec, 0xba, 0x49, 0x2a, 0xe9, 0x32, 0xa8,
	0x1c, 0x46, 0x16, 0x9b, 0x3a, 0x74, 0x2a, 0xde, 0x44, 0x93, 0xa1, 0xc3, 0x0f, 0x19, 0xb7, 0x23,
	0x27, 0x64, 0x64, 0x19, 0x9a, 0x2b, 0x53, 0x95, 0x33, 0x0d, 0x7f, 0xec, 0x84, 0xac, 0x28, 0x67,
	0x3d, 0xc8, 0xb4, 0x4a, 0x3c, 0x6e, 0xa3, 0x65, 0xf5, 0x88, 0xb1, 0xe3, 0xe3, 0x88, 0x71, 0x71,
	0xe0, 0xb7, 0xec, 0x06, 0x8f, 0x43, 0xbb, 0xe5, 0x70, 0x16, 0x25, 0xe4, 0x3a, 0x84, 0xe0, 0x3b,
	0x5d, 0x49, 0xaf, 0x2a, 0xa9, 0x47, 0xb9, 0xd0, 0x36, 0x8f, 0xc3, 0x5d, 0x10, 0x49, 0x25, 0x7d,
	0x33, 0xaf, 0x78, 0xc3, 0x78, 0xd3, 0x7a, 0xdd, 0x4c, 0xfc, 0x1b, 0x03, 0xcd, 0x87, 0xb1, 0x67,
	0x27, 0x7e, 0xc8, 0xec, 0x63, 0x3f, 0xf2, 0xe2, 0x63, 0x5b, 0x90, 0x37, 0x20, 0x60, 0x3f, 0x3f,
	0x97, 0x74, 0xde, 0x72, 0x8e, 0x77, 0x62, 0xef, 0xb1, 0x1f, 0xb2, 0x27, 0xc0, 0xaa, 0x3b, 0x7c,
	0x26, 0xac, 0x20, 0x45, 0x0b, 0x5a, 0x85, 0xf3, 0xc8, 0x9d, 0x76, 0x6a, 0x83, 0x5a, 0xac, 0x3e,
	0x1d, 0xf8, 0xb9, 0x81, 0x96, 0xb2, 0x63, 0xe2, 0x1e, 0x71, 0xe5, 0x9b, 0x7d, 0xcc, 0xfd, 0x84,
	0x09, 0xf2, 0x26, 0x38, 0xf3, 0x23, 0x55, 0x7a, 0x75, 0xc2, 0x67, 0xfc, 0x13, 0xa0, 0x53, 0x49,
	0x6f, 0x96, 0x4e, 0x4d, 0x85, 0x2b, 0x1d, 0x9e, 0x8d, 0xd2, 0xd9, 0x31, 0x36, 0xac, 0x61, 0x9a,
	0x54, 0x11, 0xcb, 0x73, 0xbb, 0xa1, 0x5e, 0x4c, 0x64, 0xa5, 0x57, 0xc4, 0x32, 0x62, 0x5b, 0xe1,
	0xc5, 0xe1, 0x2f, 0x83, 0xa6, 0x55, 0x91, 0xc1, 0x01, 0x9a, 0x83, 0x97, 0xac, 0xad, 0x6a, 0x81,
	0xad, 0xeb, 0x2b, 0x85, 0xfa, 0x7a, 0x25, 0xaf, 0xaf, 0x75, 0xc5, 0xf7, 0x8a, 0x2c, 0x34, 0xf7,
	0xfb, 0x15, 0xac, 0x88, 0x6c, 0x15, 0x36, 0xad, 0x3e, 0x39, 0xfc, 0x85, 0x81, 0xe6, 0x21, 0x85,
	0xe0, 0x21, 0x6c, 0xeb, 0x97, 0x30, 0x59, 0x05, 0x7b, 0x0b, 0xea, 0x21, 0xb1, 0x19, 0xb7, 0xda,
	0x96, 0xe2, 0x76, 0x80, 0xaa, 0x3f, 0x54, 0xad, 0x98, 0x5b, 0x05, 0x53, 0x49, 0xd7, 0x8a, 0x34,
	0x2a, 0xe1, 0xa5, 0x30, 0x8a, 0xc4, 0x89, 0x3c, 0x87, 0x7b, 0xea, 0xfe, 0x1f, 0xcf, 0x07, 0x56,
	0xbf, 0x22, 0xfc, 0x27, 0xe5, 0x8e, 0xa3, 0x0a, 0x28, 0x8b, 0x84, 0x9f, 0xf8, 0x4f, 0x55, 0x44,
	0xc9, 0x0d, 0x08, 0xe7, 0x89, 0xea, 0x0b, 0x37, 0x1d, 0xc1, 0xf6, 0x72, 0x6e, 0x1b, 0xfa, 0x42,
	0xb7, 0x0a, 0xa5, 0x92, 0x2e, 0x69, 0x67, 0xaa, 0xb8, 0xea, 0x81, 0x06, 0x64, 0x07, 0x21, 0xd5,
	0x06, 0xf6, 0x19, 0xb1, 0xfa, 0x64, 0x04, 0xfe, 0xa3, 0x81, 0xe6, 0x1a, 0x71, 0x10, 0xc4, 0xc7,
	0xf6, 0xa7, 0x47, 0x91, 0xab, 0xda, 0x11, 0x41, 0xcc, 0x9e, 0x97, 0x3f, 0xcc, 0xc1, 0x8f, 0xc4,
	0x96, 0xcf, 0x85, 0xf2, 0xf2, 0xd3, 0x2a, 0x54, 0x78, 0xd9, 0x87, 0x83, 0x97, 0xfd, 0xb2, 0x83,
	0x90, 0xf2, 0xb2, 0xcf, 0x88, 0x35, 0xab, 0x3d, 0x2a, 0x60, 0xfc, 0x08, 0xcd, 0xa8, 0x8c, 0xea,
	0x55, 0x07, 0xf2, 0x16, 0xb8, 0xa8, 0xde, 0x57, 0xd3, 0x8a, 0x29, 0xce, 0x75, 0x2a, 0xe9, 0x82,
	0xbe, 0xfc, 0xca, 0xa8, 0x69, 0x55, 0xa5, 0x54, 0xcd, 0x02, 0x85, 0x27, 0xaa, 0x79, 0x14, 0xa4,
	0x06, 0xda, 0xa0, 0x66, 0x29, 0xf8, 0xa7, 0x80, 0x16, 0x35, 0xab, 0x07, 0x99, 0x56, 0x89, 0xc7,
	0x0e, 0x9a, 0x82, 0xf9, 0xea, 0x96, 0x49, 0x18, 0x27, 0x37, 0xa1, 0xdb, 0x5b, 0x2c, 0x7a, 0xcb,
	0x84, 0xfb, 0x51, 0x73, 0x1b, 0xb8, 0xfa, 0x5a, 0xde, 0x63, 0xc2, 0x0c, 0x0d, 0xa6, 0x92, 0xce,
	0x83, 0x81, 0x12, 0x66, 0x5a, 0x65, 0x09, 0x7c, 0x88, 0x26, 0x38, 0x73, 0x3c, 0x3b, 0x8e, 0x82,
	0x36, 0xf9, 0xcb, 0x36, 0xb8, 0xb9, 0x73, 0x2e, 0x29, 0xde, 0x62, 0x2d, 0xce, 0x5c, 0x27, 0x61,
	0x9e, 0xc5, 0x1c, 0xef, 0x51, 0x14, 0xb4, 0xbb, 0x92, 0x1a, 0x1f, 0x14, 0xbf, 0x2d, 0x78, 0x0c,
	0x7d, 0xf1, 0xfb, 0x71, 0xe8, 0xab, 0x4b, 0x2a, 0x69, 0xc3, 0x6f, 0x8b, 0x01, 0x94, 0x18, 0xd6,
	0x38, 0xcf, 0x14, 0xe0, 0x5f, 0xa1, 0xf9, 0x4a, 0xb3, 0x0c, 0x17, 0xc7, 0x5f, 0x95, 0x51, 0xa3,
	0x7e, 0xff, 0x5c, 0x52, 0xd2, 0x33, 0xba, 0xd3, 0x6b, 0x79, 0x77, 0xdd, 0x24, 0x37, 0xbd, 0xd2,
	0xdf, 0x31, 0xef, 0xba, 0x49, 0xc9, 0x03, 0x62, 0x58, 0x33, 0x55, 0x12, 0xff, 0x0c, 0x5d, 0xd6,
	0x8d, 0x82, 0x20, 0x5f, 0x6f, 0x43, 0x91, 0xfb, 0xae, 0xaa, 0xb8, 0x3d, 0x43, 0xba, 0x01, 0x14,
	0xd5, 0xc5, 0x65, 0x53, 0x4a, 0xaa, 0xb3, 0xca, 0x46, 0x0c, 0x2b, 0xd7, 0x67, 0x06, 0x68, 0xaa,
	0xbc, 0x03, 0xea, 0x6d, 0xcd, 0xa2, 0x84, 0xfb, 0x4c, 0x10, 0x03, 0xde, 0xd6, 0xd7, 0x86, 0x6d,
	0xd4, 0xfd, 0x28, 0xe1, 0xed, 0xfa, 0x3b, 0xf9, 0x9b, 0x3a, 0x9b, 0x51, 0xb4, 0x7c, 0x6a, 0x0c,
	0xa1, 0x1c, 0x83, 0x2f, 0x2b, 0x17, 0x30, 0x3f, 0x37, 0xd0, 0xfc, 0x80, 0x1e, 0xfc, 0x2d, 0x34,
	0x16, 0xaa, 0x57, 0x57, 0xf6, 0x23, 0xe6, 0x86, 0xea, 0x21, 0x01, 0x28, 0x14, 0x16, 0x8f, 0xa9,
	0x31, 0xfd, 0x82, 0xd2, 0x34, 0xbe, 0x8b, 0x2e, 0xa9, 0x67, 0x99, 0x9f, 0xc0, 0xaf, 0x16, 0x9d,
	0x9a, 0x19, 0xf2, 0xda, 0xa9, 0x19, 0x5f, 0x7f, 0xf8, 0xe2, 0x9b, 0x95, 0x91, 0xce, 0x37, 0x2b,
	0x23, 0x2f, 0xce, 0x57, 0x8c, 0xce, 0xf9, 0x8a, 0xf1, 0xfb, 0x97, 0x2b, 0x23, 0x5f, 0xbd, 0x5c,
	0x31, 0x3a, 0x2f, 0x57, 0x46, 0xfe, 0xf5, 0x72, 0x65, 0xe4, 0x93, 0x77, 0xff, 0x8b, 0x3f, 0x64,
	0x3a, 0x36, 0xfb, 0x97, 0xe0, 0x4f, 0xd9, 0x87, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xde, 0xed,
	0x29, 0x65, 0x47, 0x15, 0x00, 0x00,
}

func (m *FolderDeviceConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FolderDeviceConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FolderDeviceConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptionPassword) > 0 {
		i -= len(m.EncryptionPassword)
		copy(dAtA[i:], m.EncryptionPassword)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.EncryptionPassword)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.IntroducedBy.ProtoSize()
		i -= size
		if _, err := m.IntroducedBy.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.DeviceID.ProtoSize()
		i -= size
		if _, err := m.DeviceID.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FolderConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FolderConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FolderConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeprecatedPullers != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.DeprecatedPullers))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xd0
	}
	if m.DeprecatedMinDiskFreePct != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeprecatedMinDiskFreePct))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xc9
	}
	if m.DeprecatedReadOnly {
		i--
		if m.DeprecatedReadOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xc0
	}
	{
		size, err := m.XattrFilter.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2
	i--
	dAtA[i] = 0xaa
	if m.SyncXattrs {
		i--
		if m.SyncXattrs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.SyncOwnership {
		i--
		if m.SyncOwnership {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.JunctionsAsDirs {
		i--
		if m.JunctionsAsDirs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.CaseSensitiveFS {
		i--
		if m.CaseSensitiveFS {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.CopyRangeMethod != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.CopyRangeMethod))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.BlockPullOrder != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.BlockPullOrder))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.DisableFsync {
		i--
		if m.DisableFsync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.MaxConcurrentWrites != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.MaxConcurrentWrites))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.RawModTimeWindowS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.RawModTimeWindowS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.CopyOwnershipFromParent {
		i--
		if m.CopyOwnershipFromParent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if len(m.MarkerName) > 0 {
		i -= len(m.MarkerName)
		copy(dAtA[i:], m.MarkerName)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.MarkerName)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.WeakHashThresholdPct != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.WeakHashThresholdPct))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.DisableTempIndexes {
		i--
		if m.DisableTempIndexes {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.DisableSparseFiles {
		i--
		if m.DisableSparseFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.MaxConflicts != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.MaxConflicts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.PullerPauseS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.PullerPauseS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ScanProgressIntervalS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.ScanProgressIntervalS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.IgnoreDelete {
		i--
		if m.IgnoreDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Order != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.Order))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Hashers != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.Hashers))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PullerMaxPendingKiB != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.PullerMaxPendingKiB))
		i--
		dAtA[i] = 0x78
	}
	if m.Copiers != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.Copiers))
		i--
		dAtA[i] = 0x70
	}
	{
		size, err := m.Versioning.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.MinDiskFree.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	if m.AutoNormalize {
		i--
		if m.AutoNormalize {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.IgnorePerms {
		i--
		if m.IgnorePerms {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.FSWatcherDelayS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.FSWatcherDelayS))
		i--
		dAtA[i] = 0x48
	}
	if m.FSWatcherEnabled {
		i--
		if m.FSWatcherEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.RescanIntervalS != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.RescanIntervalS))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Devices) > 0 {
		for iNdEx := len(m.Devices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Devices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Type != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x22
	}
	if m.FilesystemType != 0 {
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(m.FilesystemType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StringFilter) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFolderconfiguration(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StringFilterEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringFilterEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StringFilterEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permit {
		i--
		if m.Permit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Match) > 0 {
		i -= len(m.Match)
		copy(dAtA[i:], m.Match)
		i = encodeVarintFolderconfiguration(dAtA, i, uint64(len(m.Match)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFolderconfiguration(dAtA []byte, offset int, v uint64) int {
	offset -= sovFolderconfiguration(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FolderDeviceConfiguration) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.DeviceID.ProtoSize()
	n += 1 + l + sovFolderconfiguration(uint64(l))
	l = m.IntroducedBy.ProtoSize()
	n += 1 + l + sovFolderconfiguration(uint64(l))
	l = len(m.EncryptionPassword)
	if l > 0 {
		n += 1 + l + sovFolderconfiguration(uint64(l))
	}
	return n
}

func (m *FolderConfiguration) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovFolderconfiguration(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovFolderconfiguration(uint64(l))
	}
	if m.FilesystemType != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.FilesystemType))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovFolderconfiguration(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.Type))
	}
	if len(m.Devices) > 0 {
		for _, e := range m.Devices {
			l = e.ProtoSize()
			n += 1 + l + sovFolderconfiguration(uint64(l))
		}
	}
	if m.RescanIntervalS != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.RescanIntervalS))
	}
	if m.FSWatcherEnabled {
		n += 2
	}
	if m.FSWatcherDelayS != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.FSWatcherDelayS))
	}
	if m.IgnorePerms {
		n += 2
	}
	if m.AutoNormalize {
		n += 2
	}
	l = m.MinDiskFree.ProtoSize()
	n += 1 + l + sovFolderconfiguration(uint64(l))
	l = m.Versioning.ProtoSize()
	n += 1 + l + sovFolderconfiguration(uint64(l))
	if m.Copiers != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.Copiers))
	}
	if m.PullerMaxPendingKiB != 0 {
		n += 1 + sovFolderconfiguration(uint64(m.PullerMaxPendingKiB))
	}
	if m.Hashers != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.Hashers))
	}
	if m.Order != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.Order))
	}
	if m.IgnoreDelete {
		n += 3
	}
	if m.ScanProgressIntervalS != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.ScanProgressIntervalS))
	}
	if m.PullerPauseS != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.PullerPauseS))
	}
	if m.MaxConflicts != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.MaxConflicts))
	}
	if m.DisableSparseFiles {
		n += 3
	}
	if m.DisableTempIndexes {
		n += 3
	}
	if m.Paused {
		n += 3
	}
	if m.WeakHashThresholdPct != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.WeakHashThresholdPct))
	}
	l = len(m.MarkerName)
	if l > 0 {
		n += 2 + l + sovFolderconfiguration(uint64(l))
	}
	if m.CopyOwnershipFromParent {
		n += 3
	}
	if m.RawModTimeWindowS != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.RawModTimeWindowS))
	}
	if m.MaxConcurrentWrites != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.MaxConcurrentWrites))
	}
	if m.DisableFsync {
		n += 3
	}
	if m.BlockPullOrder != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.BlockPullOrder))
	}
	if m.CopyRangeMethod != 0 {
		n += 2 + sovFolderconfiguration(uint64(m.CopyRangeMethod))
	}
	if m.CaseSensitiveFS {
		n += 3
	}
	if m.JunctionsAsDirs {
		n += 3
	}
	if m.SyncOwnership {
		n += 3
	}
	if m.SyncXattrs {
		n += 3
	}
	l = m.XattrFilter.ProtoSize()
	n += 2 + l + sovFolderconfiguration(uint64(l))
	if m.DeprecatedReadOnly {
		n += 4
	}
	if m.DeprecatedMinDiskFreePct != 0 {
		n += 11
	}
	if m.DeprecatedPullers != 0 {
		n += 3 + sovFolderconfiguration(uint64(m.DeprecatedPullers))
	}
	return n
}

func (m *StringFilter) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.ProtoSize()
			n += 1 + l + sovFolderconfiguration(uint64(l))
		}
	}
	return n
}

func (m *StringFilterEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Match)
	if l > 0 {
		n += 1 + l + sovFolderconfiguration(uint64(l))
	}
	if m.Permit {
		n += 2
	}
	return n
}

func sovFolderconfiguration(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFolderconfiguration(x uint64) (n int) {
	return sovFolderconfiguration(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FolderDeviceConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFolderconfiguration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FolderDeviceConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FolderDeviceConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeviceID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntroducedBy", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.IntroducedBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFolderconfiguration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FolderConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFolderconfiguration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FolderConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FolderConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilesystemType", wireType)
			}
			m.FilesystemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilesystemType |= fs.FilesystemType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FolderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Devices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Devices = append(m.Devices, FolderDeviceConfiguration{})
			if err := m.Devices[len(m.Devices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RescanIntervalS", wireType)
			}
			m.RescanIntervalS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RescanIntervalS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FSWatcherEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FSWatcherEnabled = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FSWatcherDelayS", wireType)
			}
			m.FSWatcherDelayS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FSWatcherDelayS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnorePerms", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnorePerms = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoNormalize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoNormalize = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDiskFree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDiskFree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versioning", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Versioning.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Copiers", wireType)
			}
			m.Copiers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Copiers |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullerMaxPendingKiB", wireType)
			}
			m.PullerMaxPendingKiB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PullerMaxPendingKiB |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hashers", wireType)
			}
			m.Hashers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hashers |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= PullOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreDelete = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScanProgressIntervalS", wireType)
			}
			m.ScanProgressIntervalS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScanProgressIntervalS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PullerPauseS", wireType)
			}
			m.PullerPauseS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PullerPauseS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConflicts", wireType)
			}
			m.MaxConflicts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConflicts |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableSparseFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableSparseFiles = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableTempIndexes", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableTempIndexes = bool(v != 0)
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WeakHashThresholdPct", wireType)
			}
			m.WeakHashThresholdPct = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WeakHashThresholdPct |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarkerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarkerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyOwnershipFromParent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CopyOwnershipFromParent = bool(v != 0)
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawModTimeWindowS", wireType)
			}
			m.RawModTimeWindowS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawModTimeWindowS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConcurrentWrites", wireType)
			}
			m.MaxConcurrentWrites = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConcurrentWrites |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableFsync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableFsync = bool(v != 0)
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPullOrder", wireType)
			}
			m.BlockPullOrder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockPullOrder |= BlockPullOrder(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyRangeMethod", wireType)
			}
			m.CopyRangeMethod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyRangeMethod |= fs.CopyRangeMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaseSensitiveFS", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CaseSensitiveFS = bool(v != 0)
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JunctionsAsDirs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JunctionsAsDirs = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncOwnership", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncOwnership = bool(v != 0)
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncXattrs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SyncXattrs = bool(v != 0)
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field XattrFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.XattrFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9000:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeprecatedReadOnly = bool(v != 0)
		case 9001:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedMinDiskFreePct", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeprecatedMinDiskFreePct = float64(math.Float64frombits(v))
		case 9002:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedPullers", wireType)
			}
			m.DeprecatedPullers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedPullers |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFolderconfiguration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFolderconfiguration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, StringFilterEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFolderconfiguration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringFilterEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFolderconfiguration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringFilterEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringFilterEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Permit = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFolderconfiguration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFolderconfiguration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFolderconfiguration(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFolderconfiguration
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFolderconfiguration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFolderconfiguration
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFolderconfiguration
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFolderconfiguration
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFolderconfiguration        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFolderconfiguration          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFolderconfiguration = fmt.Errorf("proto: unexpected end of group")
)
