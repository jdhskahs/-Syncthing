// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lib/config/optionsconfiguration.proto

package config

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/syncthing/syncthing/proto/ext"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OptionsConfiguration struct {
	RawListenAddresses      []string         `protobuf:"bytes,1,rep,name=listen_addresses,json=listenAddresses,proto3" json:"listenAddresses" xml:"listenAddress" default:"default"`
	RawGlobalAnnServers     []string         `protobuf:"bytes,2,rep,name=global_discovery_servers,json=globalDiscoveryServers,proto3" json:"globalAnnounceServers" xml:"globalAnnounceServer" default:"default"`
	GlobalAnnEnabled        bool             `protobuf:"varint,3,opt,name=global_discovery_enabled,json=globalDiscoveryEnabled,proto3" json:"globalAnnounceEnabled" xml:"globalAnnounceEnabled" default:"true"`
	LocalAnnEnabled         bool             `protobuf:"varint,4,opt,name=local_discovery_enabled,json=localDiscoveryEnabled,proto3" json:"localAnnounceEnabled" xml:"localAnnounceEnabled" default:"true"`
	LocalAnnPort            int              `protobuf:"varint,5,opt,name=local_announce_port,json=localAnnouncePort,proto3,casttype=int" json:"localAnnouncePort" xml:"localAnnouncePort" default:"21027"`
	LocalAnnMCAddr          string           `protobuf:"bytes,6,opt,name=local_announce_multicast_address,json=localAnnounceMulticastAddress,proto3" json:"localAnnounceMCAddr" xml:"localAnnounceMCAddr" default:"[ff12::8384]:21027"`
	MaxSendKbps             int              `protobuf:"varint,7,opt,name=max_send_kbps,json=maxSendKbps,proto3,casttype=int" json:"maxSendKbps" xml:"maxSendKbps"`
	MaxRecvKbps             int              `protobuf:"varint,8,opt,name=max_recv_kbps,json=maxRecvKbps,proto3,casttype=int" json:"maxRecvKbps" xml:"maxRecvKbps"`
	ReconnectIntervalS      int              `protobuf:"varint,9,opt,name=reconnection_interval_s,json=reconnectionIntervalS,proto3,casttype=int" json:"reconnectionIntervalS" xml:"reconnectionIntervalS" default:"60"`
	RelaysEnabled           bool             `protobuf:"varint,10,opt,name=relays_enabled,json=relaysEnabled,proto3" json:"relaysEnabled" xml:"relaysEnabled" default:"true"`
	RelayReconnectIntervalM int              `protobuf:"varint,11,opt,name=relays_reconnect_interval_m,json=relaysReconnectIntervalM,proto3,casttype=int" json:"relayReconnectIntervalM" xml:"relayReconnectIntervalM" default:"10"`
	StartBrowser            bool             `protobuf:"varint,12,opt,name=start_browser,json=startBrowser,proto3" json:"startBrowser" xml:"startBrowser" default:"true"`
	NATEnabled              bool             `protobuf:"varint,14,opt,name=nat_traversal_enabled,json=natTraversalEnabled,proto3" json:"natEnabled" xml:"natEnabled" default:"true"`
	NATLeaseM               int              `protobuf:"varint,15,opt,name=nat_traversal_lease_m,json=natTraversalLeaseM,proto3,casttype=int" json:"natLeaseMinutes" xml:"natLeaseMinutes" default:"60"`
	NATRenewalM             int              `protobuf:"varint,16,opt,name=nat_traversal_renewal_m,json=natTraversalRenewalM,proto3,casttype=int" json:"natRenewalMinutes" xml:"natRenewalMinutes" default:"30"`
	NATTimeoutS             int              `protobuf:"varint,17,opt,name=nat_traversal_timeout_s,json=natTraversalTimeoutS,proto3,casttype=int" json:"natTimeoutSeconds" xml:"natTimeoutSeconds" default:"10"`
	URAccepted              int              `protobuf:"varint,18,opt,name=usage_reporting_accepted,json=usageReportingAccepted,proto3,casttype=int" json:"urAccepted" xml:"urAccepted"`
	URSeen                  int              `protobuf:"varint,19,opt,name=usage_reporting_seen,json=usageReportingSeen,proto3,casttype=int" json:"urSeen" xml:"urSeen"`
	URUniqueID              string           `protobuf:"bytes,20,opt,name=usage_reporting_unique_id,json=usageReportingUniqueId,proto3" json:"urUniqueId" xml:"urUniqueID"`
	URURL                   string           `protobuf:"bytes,21,opt,name=usage_reporting_url,json=usageReportingUrl,proto3" json:"urURL" xml:"urURL" default:"https://data.syncthing.net/newdata"`
	URPostInsecurely        bool             `protobuf:"varint,22,opt,name=usage_reporting_post_insecurely,json=usageReportingPostInsecurely,proto3" json:"urPostInsecurely" xml:"urPostInsecurely" default:"false"`
	URInitialDelayS         int              `protobuf:"varint,23,opt,name=usage_reporting_initial_delay_s,json=usageReportingInitialDelayS,proto3,casttype=int" json:"urInitialDelayS" xml:"urInitialDelayS" default:"1800"`
	RestartOnWakeup         bool             `protobuf:"varint,24,opt,name=restart_on_wakeup,json=restartOnWakeup,proto3" json:"restartOnWakeup" xml:"restartOnWakeup" default:"true"`
	AutoUpgradeIntervalH    int              `protobuf:"varint,25,opt,name=auto_upgrade_interval_h,json=autoUpgradeIntervalH,proto3,casttype=int" json:"autoUpgradeIntervalH" xml:"autoUpgradeIntervalH" default:"12"`
	UpgradeToPreReleases    bool             `protobuf:"varint,26,opt,name=upgrade_to_pre_releases,json=upgradeToPreReleases,proto3" json:"upgradeToPreReleases" xml:"upgradeToPreReleases"`
	KeepTemporariesH        int              `protobuf:"varint,27,opt,name=keep_temporaries_h,json=keepTemporariesH,proto3,casttype=int" json:"keepTemporariesH" xml:"keepTemporariesH" default:"24"`
	CacheIgnoredFiles       bool             `protobuf:"varint,28,opt,name=cache_ignored_files,json=cacheIgnoredFiles,proto3" json:"cacheIgnoredFiles" xml:"cacheIgnoredFiles" default:"false"`
	ProgressUpdateIntervalS int              `protobuf:"varint,29,opt,name=progress_update_interval_s,json=progressUpdateIntervalS,proto3,casttype=int" json:"progressUpdateIntervalS" xml:"progressUpdateIntervalS" default:"5"`
	LimitBandwidthInLan     bool             `protobuf:"varint,30,opt,name=limit_bandwidth_in_lan,json=limitBandwidthInLan,proto3" json:"limitBandwidthInLan" xml:"limitBandwidthInLan" default:"false"`
	MinHomeDiskFree         Size             `protobuf:"bytes,31,opt,name=min_home_disk_free,json=minHomeDiskFree,proto3" json:"minHomeDiskFree" xml:"minHomeDiskFree" default:"1 %"`
	ReleasesURL             string           `protobuf:"bytes,32,opt,name=releases_url,json=releasesUrl,proto3" json:"releasesURL" xml:"releasesURL" default:"https://upgrades.syncthing.net/meta.json"`
	AlwaysLocalNets         []string         `protobuf:"bytes,33,rep,name=always_local_nets,json=alwaysLocalNets,proto3" json:"alwaysLocalNets" xml:"alwaysLocalNet"`
	OverwriteRemoteDevNames bool             `protobuf:"varint,34,opt,name=overwrite_remote_device_names_on_connect,json=overwriteRemoteDeviceNamesOnConnect,proto3" json:"overwriteRemoteDeviceNamesOnConnect" xml:"overwriteRemoteDeviceNamesOnConnect" default:"false"`
	TempIndexMinBlocks      int              `protobuf:"varint,35,opt,name=temp_index_min_blocks,json=tempIndexMinBlocks,proto3,casttype=int" json:"tempIndexMinBlocks" xml:"tempIndexMinBlocks" default:"10"`
	UnackedNotificationIDs  []string         `protobuf:"bytes,36,rep,name=unacked_notification_ids,json=unackedNotificationIds,proto3" json:"unackedNotificationIDs" xml:"unackedNotificationID"`
	TrafficClass            int              `protobuf:"varint,37,opt,name=traffic_class,json=trafficClass,proto3,casttype=int" json:"trafficClass" xml:"trafficClass"`
	DefaultFolderPath       string           `protobuf:"bytes,38,opt,name=default_folder_path,json=defaultFolderPath,proto3" json:"defaultFolderPath" xml:"defaultFolderPath" default:"~"`
	SetLowPriority          bool             `protobuf:"varint,39,opt,name=set_low_priority,json=setLowPriority,proto3" json:"setLowPriority" xml:"setLowPriority" default:"true"`
	RawMaxFolderConcurrency int              `protobuf:"varint,40,opt,name=max_folder_concurrency,json=maxFolderConcurrency,proto3,casttype=int" json:"maxFolderConcurrency" xml:"maxFolderConcurrency"`
	CRURL                   string           `protobuf:"bytes,41,opt,name=crash_reporting_url,json=crashReportingUrl,proto3" json:"crURL" xml:"crashReportingURL" default:"https://crash.syncthing.net/newcrash"`
	CREnabled               bool             `protobuf:"varint,42,opt,name=crash_reporting_enabled,json=crashReportingEnabled,proto3" json:"crashReportingEnabled" xml:"crashReportingEnabled" default:"true"`
	StunKeepaliveStartS     int              `protobuf:"varint,43,opt,name=stun_keepalive_start_s,json=stunKeepaliveStartS,proto3,casttype=int" json:"stunKeepaliveStartS" xml:"stunKeepaliveStartS" default:"180"`
	StunKeepaliveMinS       int              `protobuf:"varint,44,opt,name=stun_keepalive_min_s,json=stunKeepaliveMinS,proto3,casttype=int" json:"stunKeepaliveMinS" xml:"stunKeepaliveMinS" default:"20"`
	RawStunServers          []string         `protobuf:"bytes,45,rep,name=stun_servers,json=stunServers,proto3" json:"stunServers" xml:"stunServer" default:"default"`
	DatabaseTuning          Tuning           `protobuf:"varint,46,opt,name=database_tuning,json=databaseTuning,proto3,enum=config.Tuning" json:"databaseTuning" xml:"databaseTuning" restart:"true"`
	RawMaxCIRequestKiB      int              `protobuf:"varint,47,opt,name=max_concurrent_incoming_request_kib,json=maxConcurrentIncomingRequestKib,proto3,casttype=int" json:"maxConcurrentIncomingRequestKiB" xml:"maxConcurrentIncomingRequestKiB"`
	AnnounceLANAddresses    bool             `protobuf:"varint,48,opt,name=announce_lan_addresses,json=announceLanAddresses,proto3" json:"announceLANAddresses" xml:"announceLANAddresses" default:"true"`
	SendFullIndexOnUpgrade  bool             `protobuf:"varint,49,opt,name=send_full_index_on_upgrade,json=sendFullIndexOnUpgrade,proto3" json:"sendFullIndexOnUpgrade" xml:"sendFullIndexOnUpgrade"`
	FeatureFlags            []string         `protobuf:"bytes,50,rep,name=feature_flags,json=featureFlags,proto3" json:"featureFlags" xml:"featureFlag"`
	ConnectionLimits        ConnectionLimits `protobuf:"bytes,51,opt,name=connection_limits,json=connectionLimits,proto3" json:"connectionLimits" xml:"connectionLimits"`
	// Legacy deprecated
	DeprecatedUPnPEnabled        bool     `protobuf:"varint,9000,opt,name=upnp_enabled,json=upnpEnabled,proto3" json:"-" xml:"upnpEnabled,omitempty"`                                    // Deprecated: Do not use.
	DeprecatedUPnPLeaseM         int      `protobuf:"varint,9001,opt,name=upnp_lease_m,json=upnpLeaseM,proto3,casttype=int" json:"-" xml:"upnpLeaseMinutes,omitempty"`                   // Deprecated: Do not use.
	DeprecatedUPnPRenewalM       int      `protobuf:"varint,9002,opt,name=upnp_renewal_m,json=upnpRenewalM,proto3,casttype=int" json:"-" xml:"upnpRenewalMinutes,omitempty"`             // Deprecated: Do not use.
	DeprecatedUPnPTimeoutS       int      `protobuf:"varint,9003,opt,name=upnp_timeout_s,json=upnpTimeoutS,proto3,casttype=int" json:"-" xml:"upnpTimeoutSeconds,omitempty"`             // Deprecated: Do not use.
	DeprecatedRelayServers       []string `protobuf:"bytes,9004,rep,name=relay_servers,json=relayServers,proto3" json:"-" xml:"relayServer,omitempty"`                                   // Deprecated: Do not use.
	DeprecatedMinHomeDiskFreePct float64  `protobuf:"fixed64,9005,opt,name=min_home_disk_free_pct,json=minHomeDiskFreePct,proto3" json:"-" xml:"minHomeDiskFreePct,omitempty"`           // Deprecated: Do not use.
	DeprecatedMaxConcurrentScans int      `protobuf:"varint,9006,opt,name=max_concurrent_scans,json=maxConcurrentScans,proto3,casttype=int" json:"-" xml:"maxConcurrentScans,omitempty"` // Deprecated: Do not use.
}

func (m *OptionsConfiguration) Reset()         { *m = OptionsConfiguration{} }
func (m *OptionsConfiguration) String() string { return proto.CompactTextString(m) }
func (*OptionsConfiguration) ProtoMessage()    {}
func (*OptionsConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_d09882599506ca03, []int{0}
}
func (m *OptionsConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptionsConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptionsConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptionsConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptionsConfiguration.Merge(m, src)
}
func (m *OptionsConfiguration) XXX_Size() int {
	return m.ProtoSize()
}
func (m *OptionsConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_OptionsConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_OptionsConfiguration proto.InternalMessageInfo

type ConnectionLimits struct {
	// The number of connections at which we stop trying to connect to more
	// devices, zero meaning no limit. Does not affect incoming connections.
	Enough int `protobuf:"varint,1,opt,name=enough,proto3,casttype=int" json:"enough" xml:"enough"`
	// The maximum number of connections which we will allow in total, zero
	// meaning no limit. Affects incoming connections and prevents
	// attempting outgoing connections.
	Max int `protobuf:"varint,2,opt,name=max,proto3,casttype=int" json:"max" xml:"max"`
}

func (m *ConnectionLimits) Reset()         { *m = ConnectionLimits{} }
func (m *ConnectionLimits) String() string { return proto.CompactTextString(m) }
func (*ConnectionLimits) ProtoMessage()    {}
func (*ConnectionLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_d09882599506ca03, []int{1}
}
func (m *ConnectionLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionLimits.Merge(m, src)
}
func (m *ConnectionLimits) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ConnectionLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionLimits.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionLimits proto.InternalMessageInfo

func init() {
	proto.RegisterType((*OptionsConfiguration)(nil), "config.OptionsConfiguration")
	proto.RegisterType((*ConnectionLimits)(nil), "config.ConnectionLimits")
}

func init() {
	proto.RegisterFile("lib/config/optionsconfiguration.proto", fileDescriptor_d09882599506ca03)
}

var fileDescriptor_d09882599506ca03 = []byte{
	// 3236 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x5a, 0x5d, 0x6c, 0x1d, 0x47,
	0xf5, 0xcf, 0x26, 0x4d, 0xda, 0x6c, 0x1c, 0xc7, 0x1e, 0x3b, 0xf6, 0x36, 0x49, 0xbd, 0xee, 0xcd,
	0x4d, 0xeb, 0x7e, 0x24, 0xb1, 0x9d, 0x36, 0xff, 0x34, 0xd2, 0x5f, 0xe0, 0x8f, 0xba, 0x75, 0x63,
	0x3b, 0xd6, 0xd8, 0x56, 0x51, 0x11, 0x5a, 0xcd, 0xdd, 0x3b, 0xd7, 0x5e, 0xbc, 0x77, 0xf6, 0x66,
	0x67, 0xd6, 0x1f, 0xa5, 0x2a, 0x55, 0x11, 0x1f, 0x6f, 0x80, 0xc5, 0x87, 0x04, 0x12, 0x2a, 0x02,
	0x24, 0x4a, 0x29, 0x42, 0x42, 0x42, 0x82, 0x17, 0x10, 0x12, 0x52, 0x05, 0x0f, 0xf6, 0x23, 0x12,
	0x65, 0x51, 0x9d, 0x3e, 0xdd, 0x07, 0x1e, 0xee, 0xa3, 0x79, 0x41, 0x33, 0xfb, 0x35, 0xbb, 0x3b,
	0xb7, 0xc9, 0xdb, 0x9d, 0xf3, 0x3b, 0x73, 0xe6, 0x77, 0x66, 0x67, 0xce, 0x9c, 0x33, 0x73, 0xf5,
	0x2b, 0xae, 0x53, 0xbb, 0x6e, 0x7b, 0xa4, 0xe1, 0xac, 0x5f, 0xf7, 0x5a, 0xcc, 0xf1, 0x08, 0x8d,
	0x5a, 0x81, 0x8f, 0x78, 0xeb, 0x5a, 0xcb, 0xf7, 0x98, 0x07, 0x4e, 0x45, 0xc2, 0x0b, 0xc3, 0x92,
	0x3a, 0x0b, 0x88, 0x43, 0xd6, 0x23, 0x85, 0x0b, 0xe7, 0x25, 0x80, 0x3a, 0x6f, 0xe2, 0x58, 0x7c,
	0x1a, 0xef, 0xb0, 0xe8, 0x67, 0xe5, 0xfe, 0x2b, 0xfa, 0xe0, 0xdd, 0x68, 0x84, 0x19, 0x79, 0x04,
	0xf0, 0x13, 0x4d, 0xef, 0x73, 0x1d, 0xca, 0x30, 0xb1, 0x50, 0xbd, 0xee, 0x63, 0x4a, 0x31, 0x35,
	0xb4, 0xd1, 0x13, 0x63, 0xa7, 0xa7, 0xe9, 0x61, 0x68, 0x02, 0x88, 0xb6, 0x17, 0x04, 0x3c, 0x95,
	0xa0, 0xed, 0xd0, 0x3c, 0xe7, 0xe6, 0x45, 0x9d, 0xd0, 0xbc, 0xb2, 0xd3, 0x74, 0x6f, 0x57, 0x72,
	0xf2, 0xca, 0x68, 0x1d, 0x37, 0x50, 0xe0, 0xb2, 0xdb, 0x95, 0xf8, 0x47, 0xe5, 0x68, 0xbf, 0xfa,
	0x68, 0xfc, 0x7b, 0xef, 0xa0, 0xaa, 0x30, 0x0e, 0x8b, 0xa6, 0xc1, 0x7f, 0x34, 0xdd, 0x58, 0x77,
	0xbd, 0x1a, 0x72, 0xad, 0xba, 0x43, 0x6d, 0x6f, 0x0b, 0xfb, 0xbb, 0x16, 0xc5, 0xfe, 0x16, 0xf6,
	0xa9, 0x71, 0x5c, 0x10, 0xfd, 0x9d, 0x76, 0x18, 0x9a, 0x03, 0x10, 0x6d, 0xbf, 0x22, 0xf4, 0xa6,
	0x08, 0x59, 0x89, 0xf0, 0x76, 0x68, 0x9e, 0x5f, 0x4f, 0x64, 0x5e, 0x40, 0x6c, 0x1c, 0x03, 0x9d,
	0xd0, 0x7c, 0x5e, 0x10, 0x56, 0xa1, 0x0a, 0xde, 0xed, 0xfd, 0xea, 0xa0, 0x4a, 0xb5, 0xb3, 0x5f,
	0x55, 0x0f, 0x90, 0x77, 0x54, 0xc5, 0x0d, 0x0e, 0x45, 0x1d, 0x67, 0x13, 0xa7, 0x62, 0x39, 0xf8,
	0x54, 0xe5, 0x30, 0x26, 0xa8, 0xe6, 0xe2, 0xba, 0x71, 0x62, 0x54, 0x1b, 0x7b, 0x6c, 0xfa, 0x7d,
	0xee, 0x70, 0x5f, 0x6a, 0xf1, 0xe5, 0x08, 0x2c, 0x7b, 0x1b, 0x03, 0x9d, 0xd0, 0x7c, 0x56, 0xe1,
	0x6d, 0x8c, 0x4a, 0xee, 0x32, 0x3f, 0xc0, 0xdc, 0xd7, 0x2e, 0x66, 0xba, 0x01, 0x47, 0xfb, 0xd5,
	0x47, 0x78, 0xd7, 0xbd, 0x83, 0x6a, 0x89, 0x54, 0xc9, 0xcd, 0x58, 0x0e, 0x3e, 0xd6, 0xf4, 0x61,
	0xd7, 0xb3, 0x95, 0x5e, 0x3e, 0x22, 0xbc, 0xfc, 0x19, 0xf7, 0xf2, 0xdc, 0x02, 0xd7, 0xc9, 0x39,
	0x39, 0xe8, 0xc6, 0xa2, 0x82, 0x8f, 0xcf, 0x44, 0x4b, 0x50, 0x01, 0x2a, 0x5c, 0x54, 0x1b, 0xe9,
	0x22, 0x97, 0x1c, 0x2c, 0xf2, 0x81, 0xe7, 0x45, 0x87, 0x92, 0x7b, 0x7f, 0xd7, 0xf4, 0x81, 0xc8,
	0x3d, 0x14, 0xdb, 0xb2, 0x5a, 0x9e, 0xcf, 0x8c, 0x93, 0xa3, 0xda, 0xd8, 0xc9, 0xe9, 0x1f, 0x71,
	0xd7, 0x7a, 0x12, 0x53, 0xcb, 0x9e, 0xcf, 0xda, 0xa1, 0xd9, 0x9f, 0x1b, 0x9a, 0x0b, 0x3b, 0xa1,
	0xf9, 0x74, 0xd9, 0x29, 0x8e, 0x48, 0x1e, 0x4d, 0x4e, 0x8c, 0x4f, 0xfe, 0x5f, 0xe5, 0x28, 0x34,
	0x4f, 0x38, 0x84, 0xb5, 0xf7, 0xab, 0x0a, 0x33, 0x2a, 0xe1, 0xd1, 0x7e, 0xf5, 0xa4, 0xe8, 0xba,
	0x77, 0x50, 0xcd, 0x31, 0x81, 0x65, 0x5d, 0xf0, 0xb5, 0xe3, 0xfa, 0x68, 0xc1, 0x9b, 0x66, 0xe0,
	0x32, 0xc7, 0x46, 0x94, 0x25, 0x71, 0xc3, 0x38, 0x35, 0xaa, 0x8d, 0x9d, 0x9e, 0xfe, 0x03, 0x77,
	0xad, 0x37, 0x31, 0xb8, 0x38, 0xc3, 0x77, 0x72, 0x3b, 0x34, 0x07, 0x72, 0x46, 0x23, 0x71, 0x27,
	0x34, 0x6f, 0x96, 0xdd, 0x8b, 0x30, 0xc9, 0xc1, 0x2f, 0x36, 0x1a, 0x13, 0x93, 0xb7, 0x6f, 0xdf,
	0xba, 0x71, 0xeb, 0x85, 0x2f, 0xdd, 0x8e, 0xbc, 0x6d, 0xef, 0x57, 0x95, 0x06, 0xd5, 0xe2, 0xa3,
	0xfd, 0x2a, 0x28, 0x1b, 0xd9, 0x3b, 0xa8, 0x16, 0x68, 0xc2, 0x27, 0xf2, 0x9d, 0x13, 0x0f, 0xe3,
	0x60, 0x04, 0xee, 0xea, 0x67, 0x9b, 0x68, 0xc7, 0xa2, 0x98, 0xd4, 0xad, 0xcd, 0x5a, 0x8b, 0x1a,
	0x8f, 0x8a, 0x8f, 0xf9, 0x5c, 0x3b, 0x34, 0xcf, 0x34, 0xd1, 0xce, 0x0a, 0x26, 0xf5, 0x3b, 0xb5,
	0x16, 0x0f, 0x2e, 0xfd, 0xc2, 0x2d, 0x49, 0x96, 0x7c, 0x1f, 0x28, 0x2b, 0x26, 0x06, 0x7d, 0x6c,
	0x6f, 0x45, 0x06, 0x1f, 0xcb, 0x19, 0x84, 0xd8, 0xde, 0x2a, 0x1a, 0x4c, 0x64, 0x39, 0x83, 0x89,
	0x10, 0xfc, 0x5e, 0xd3, 0x87, 0x7d, 0x6c, 0x7b, 0x84, 0x60, 0x9b, 0x87, 0x77, 0xcb, 0x21, 0x0c,
	0xfb, 0x5b, 0xc8, 0xb5, 0xa8, 0x71, 0x5a, 0xd8, 0x7e, 0x5b, 0x04, 0xf5, 0x44, 0x65, 0x3e, 0x86,
	0x57, 0x78, 0xec, 0x90, 0x3b, 0xa6, 0x40, 0x27, 0x34, 0xc7, 0xc4, 0xd8, 0x4a, 0x54, 0xfa, 0x4a,
	0x37, 0xc7, 0x13, 0x4a, 0x47, 0xfb, 0xd5, 0xe3, 0x37, 0xc7, 0x45, 0x7c, 0x2f, 0x8d, 0x03, 0xd5,
	0xa3, 0x80, 0x86, 0xde, 0xeb, 0x63, 0x17, 0xed, 0xd2, 0x34, 0x06, 0xe8, 0x22, 0x06, 0x7c, 0xae,
	0x1d, 0x9a, 0x67, 0x23, 0x24, 0xdb, 0xe8, 0x95, 0x98, 0x90, 0x24, 0x2d, 0xee, 0xf0, 0x64, 0xc7,
	0xc2, 0x7c, 0x67, 0xf0, 0xee, 0x71, 0xfd, 0x62, 0x3c, 0x50, 0x4a, 0x24, 0x9b, 0xa4, 0xa6, 0x71,
	0x46, 0x4c, 0xd2, 0x5f, 0xf8, 0x1a, 0x1e, 0x86, 0x5c, 0xaf, 0xe4, 0xc2, 0x62, 0x3b, 0x34, 0x87,
	0x7d, 0x35, 0x94, 0x06, 0xda, 0x2e, 0xb8, 0xc4, 0x72, 0x62, 0x5c, 0xda, 0xb2, 0x5d, 0xed, 0x75,
	0x87, 0xf8, 0x24, 0x4f, 0xf0, 0x49, 0xee, 0x46, 0x13, 0x1a, 0x91, 0x9f, 0x65, 0x04, 0xd4, 0xf4,
	0xb3, 0x94, 0x21, 0x9f, 0x59, 0x35, 0xdf, 0xdb, 0xa6, 0xd8, 0x37, 0x7a, 0xc4, 0x5c, 0xff, 0x7f,
	0x3b, 0x34, 0x7b, 0x04, 0x30, 0x1d, 0xc9, 0x3b, 0xa1, 0xf9, 0xa4, 0x70, 0x47, 0x16, 0x76, 0x9d,
	0xe9, 0x5c, 0x57, 0xf0, 0x0b, 0x4d, 0x3f, 0x4f, 0x10, 0xb3, 0x98, 0x8f, 0xf8, 0xa9, 0x86, 0xdc,
	0xf4, 0xc3, 0xf6, 0x8a, 0xc1, 0xee, 0x1d, 0x86, 0xa6, 0xbe, 0x34, 0xb5, 0x9a, 0x85, 0x75, 0x9d,
	0x20, 0x96, 0x7d, 0x63, 0x53, 0x0c, 0x9c, 0x89, 0x14, 0x21, 0x5c, 0xee, 0x90, 0x6b, 0x49, 0xe1,
	0x5a, 0x1a, 0x02, 0x0e, 0x10, 0xc4, 0x56, 0x13, 0x3a, 0xc9, 0x82, 0xf8, 0x63, 0x89, 0xa7, 0x8b,
	0x11, 0xc5, 0x56, 0xd3, 0x38, 0x27, 0x96, 0xc2, 0x37, 0xf8, 0x52, 0x38, 0xbd, 0x34, 0xb5, 0xba,
	0xc0, 0xc5, 0xfc, 0xe3, 0x9f, 0x23, 0x88, 0x45, 0x0d, 0x87, 0x04, 0x4c, 0x24, 0x3f, 0x95, 0x84,
	0xac, 0x2c, 0x57, 0xee, 0x8d, 0xf6, 0x7e, 0xb5, 0xd4, 0xbf, 0x2c, 0x4a, 0x77, 0x50, 0x36, 0x30,
	0x04, 0x32, 0xfb, 0x48, 0x06, 0xfe, 0xa6, 0xe9, 0xc3, 0x79, 0xf2, 0x3e, 0x26, 0x78, 0x5b, 0xac,
	0xe4, 0x3e, 0x41, 0x7f, 0x8f, 0xd3, 0x3f, 0xb3, 0x34, 0xb5, 0x0a, 0x23, 0x80, 0x3b, 0xd0, 0x4f,
	0x10, 0x4b, 0x9a, 0xa9, 0x0b, 0xd5, 0xc4, 0x85, 0x3c, 0x22, 0x39, 0x71, 0x43, 0x76, 0x42, 0x61,
	0x43, 0x25, 0xe4, 0x8e, 0xdc, 0xe0, 0x8e, 0xc8, 0x14, 0xe0, 0xa0, 0xec, 0x4a, 0x22, 0x55, 0x38,
	0xc3, 0x9c, 0x26, 0xf6, 0x02, 0x66, 0x51, 0xa3, 0x3f, 0xef, 0xcc, 0x6a, 0x04, 0xac, 0xc4, 0xce,
	0x24, 0x4d, 0xbe, 0xd2, 0xeb, 0x39, 0x67, 0xf2, 0x48, 0xb7, 0xed, 0xa7, 0xb0, 0xa1, 0x12, 0xa6,
	0x5b, 0x4e, 0xa6, 0x90, 0x77, 0x26, 0x91, 0x82, 0x1f, 0x6b, 0xba, 0x11, 0x50, 0xb4, 0x8e, 0x2d,
	0x1f, 0xf3, 0x73, 0xdf, 0x21, 0xeb, 0x16, 0xb2, 0x6d, 0xdc, 0x62, 0xb8, 0x6e, 0x00, 0xe1, 0x0d,
	0xe2, 0x3b, 0x60, 0x0d, 0x4e, 0xc5, 0x52, 0xbe, 0x03, 0x02, 0x3f, 0x69, 0x75, 0x42, 0xb3, 0x4f,
	0x38, 0x91, 0x89, 0x24, 0xc2, 0xb2, 0x62, 0xae, 0xc5, 0x57, 0x7c, 0x66, 0x12, 0x0e, 0x09, 0x0a,
	0x30, 0x61, 0x90, 0xc8, 0xc1, 0x57, 0xf4, 0xc1, 0x22, 0x39, 0x8a, 0x31, 0x31, 0x06, 0x04, 0xb1,
	0xf9, 0xc3, 0xd0, 0x3c, 0xb5, 0x06, 0x57, 0x30, 0x26, 0xed, 0xd0, 0x3c, 0x15, 0xf8, 0xfc, 0x57,
	0x27, 0x34, 0x7b, 0x62, 0x42, 0xbc, 0x29, 0x91, 0x49, 0x14, 0xd2, 0x5f, 0x7b, 0x07, 0xd5, 0xb8,
	0x3b, 0x04, 0x79, 0x02, 0x5c, 0x06, 0xbe, 0xaf, 0xe9, 0x8f, 0x17, 0x47, 0x0f, 0x88, 0x73, 0x2f,
	0xc0, 0x96, 0x53, 0x37, 0x06, 0x45, 0x12, 0xf1, 0x46, 0x34, 0x37, 0x6b, 0x42, 0x3c, 0x3f, 0x1b,
	0xcd, 0x4d, 0xdc, 0x92, 0xe7, 0x26, 0x51, 0xa8, 0x44, 0x93, 0x92, 0x34, 0x3b, 0x72, 0x2b, 0x9e,
	0x94, 0x04, 0x2b, 0x4e, 0x4a, 0xa2, 0x05, 0xfe, 0xac, 0xe9, 0x03, 0x25, 0x5e, 0xbe, 0x6b, 0x9c,
	0x17, 0x8c, 0xbe, 0xcd, 0xd7, 0xde, 0xc9, 0x35, 0xb8, 0x06, 0x17, 0xda, 0xa1, 0x79, 0x32, 0xf0,
	0xd7, 0xe0, 0x42, 0x27, 0x34, 0x6f, 0x25, 0x44, 0xe0, 0x82, 0xb4, 0xba, 0x36, 0x18, 0x6b, 0xd1,
	0xdb, 0xd7, 0xaf, 0xd7, 0x11, 0x43, 0xd7, 0xe8, 0x2e, 0xb1, 0xd9, 0x06, 0x2f, 0xd6, 0x08, 0x66,
	0xd7, 0x09, 0xde, 0xe6, 0x52, 0x4e, 0x38, 0x36, 0x92, 0xfc, 0x38, 0xda, 0xaf, 0x3e, 0x44, 0xc7,
	0xbd, 0x83, 0x6a, 0xc4, 0x02, 0xf6, 0x17, 0xfc, 0xf0, 0x5d, 0xf0, 0x6f, 0x4d, 0x37, 0x8b, 0x2e,
	0xb4, 0x3c, 0xca, 0x4f, 0x38, 0x8a, 0xed, 0xc0, 0xc7, 0xee, 0xae, 0x31, 0x24, 0xc2, 0xef, 0x0f,
	0x45, 0x05, 0xb1, 0x06, 0x97, 0x3d, 0xca, 0xe6, 0x53, 0xb0, 0x1d, 0x9a, 0x7d, 0x81, 0x9f, 0x97,
	0x75, 0x42, 0xf3, 0xa9, 0xd8, 0xc9, 0x3c, 0x20, 0xf9, 0xdb, 0x40, 0x2e, 0x15, 0x21, 0xb9, 0xdc,
	0x5b, 0x21, 0xe3, 0x99, 0xa7, 0xe8, 0xc1, 0xeb, 0x85, 0x22, 0x05, 0x78, 0x29, 0xef, 0x56, 0x1e,
	0x05, 0xff, 0x52, 0x78, 0xe8, 0x10, 0x87, 0x39, 0xbc, 0x8e, 0xe0, 0xe7, 0x9d, 0x45, 0x8d, 0x61,
	0xb1, 0x8a, 0x7f, 0x20, 0xaa, 0x87, 0x35, 0x38, 0x1f, 0xa1, 0xb3, 0x1c, 0xe4, 0x01, 0xe3, 0x5c,
	0xe0, 0xe7, 0x44, 0x69, 0xb8, 0x28, 0xc8, 0xe5, 0x60, 0x71, 0x6b, 0x3c, 0x17, 0xc0, 0x8b, 0x16,
	0xca, 0x22, 0x7e, 0x02, 0xf1, 0x5e, 0xbc, 0x60, 0x28, 0x50, 0x80, 0x17, 0xf3, 0x0e, 0xe6, 0x40,
	0xe0, 0xe9, 0xfd, 0x3e, 0x8e, 0x0e, 0x67, 0x8f, 0x58, 0xdb, 0x68, 0x13, 0x07, 0x2d, 0xc3, 0x10,
	0x9f, 0x6c, 0x86, 0x93, 0x8f, 0xc1, 0xbb, 0xe4, 0x75, 0x01, 0xa5, 0xe4, 0x0b, 0xf2, 0xae, 0x87,
	0x74, 0xd1, 0x00, 0xf8, 0xa6, 0xa6, 0x0f, 0xa3, 0x80, 0x79, 0x56, 0xd0, 0x5a, 0xf7, 0x51, 0x1d,
	0x67, 0xc9, 0xd0, 0x86, 0xf1, 0xb8, 0x98, 0xc8, 0x65, 0x5e, 0x72, 0x71, 0x95, 0xb5, 0x48, 0x23,
	0xc9, 0x23, 0x5e, 0x4d, 0xab, 0x13, 0x15, 0x28, 0x4f, 0xdf, 0xa4, 0x9c, 0x19, 0x4e, 0x4c, 0x42,
	0xa5, 0x35, 0xd0, 0xd4, 0x87, 0x13, 0x0e, 0xcc, 0xb3, 0x5a, 0x3e, 0xff, 0xc4, 0xe2, 0x2c, 0xa6,
	0xc6, 0x05, 0x31, 0x01, 0x37, 0x39, 0x91, 0x58, 0x65, 0xd5, 0x5b, 0xf6, 0x31, 0x8c, 0xf1, 0x4e,
	0x68, 0x5e, 0x88, 0x3e, 0xa1, 0x02, 0xac, 0x40, 0x65, 0x1f, 0xb0, 0xa5, 0x83, 0x4d, 0x8c, 0x5b,
	0x16, 0xc3, 0xcd, 0x96, 0xe7, 0x23, 0xdf, 0xc1, 0xd4, 0xda, 0x30, 0x2e, 0x0a, 0x97, 0x5f, 0xe5,
	0x1b, 0x81, 0xa3, 0xab, 0x19, 0xc8, 0xdd, 0xbd, 0x2c, 0x46, 0x29, 0x02, 0x72, 0x2d, 0xf6, 0x82,
	0xec, 0xea, 0xe4, 0x0b, 0xb0, 0x64, 0x05, 0xec, 0xea, 0x03, 0x36, 0xb2, 0x37, 0xb0, 0xe5, 0xac,
	0x13, 0xcf, 0xc7, 0x75, 0xab, 0xe1, 0xb8, 0x98, 0x1a, 0x97, 0x84, 0x8b, 0xf3, 0xfc, 0x44, 0x13,
	0xf0, 0x7c, 0x84, 0xce, 0x71, 0x30, 0x9d, 0xe8, 0x12, 0x52, 0xda, 0x83, 0xe9, 0xde, 0x82, 0x65,
	0x33, 0xe0, 0xbb, 0x9a, 0x7e, 0xa1, 0xe5, 0x7b, 0xeb, 0xbc, 0x98, 0xb1, 0x82, 0x56, 0x1d, 0x31,
	0x2c, 0x17, 0x08, 0x4f, 0x08, 0xdf, 0x57, 0x79, 0x7e, 0x9b, 0x68, 0xad, 0x09, 0x25, 0xb9, 0x18,
	0x88, 0x8a, 0xec, 0x2e, 0xb8, 0x44, 0xe7, 0x45, 0x69, 0x22, 0xb4, 0x17, 0x61, 0x37, 0x8b, 0xe0,
	0x5d, 0x4d, 0x1f, 0x72, 0x9d, 0xa6, 0xc3, 0xac, 0x1a, 0x22, 0xf5, 0x6d, 0xa7, 0xce, 0x36, 0x2c,
	0x87, 0x58, 0x2e, 0x22, 0xc6, 0x88, 0x98, 0x92, 0x45, 0x51, 0x3c, 0x72, 0x8d, 0xe9, 0x44, 0x61,
	0x9e, 0x2c, 0x20, 0x92, 0x15, 0xfc, 0x65, 0xec, 0x33, 0xa6, 0x45, 0x65, 0x0a, 0xbc, 0xa3, 0xe9,
	0xa0, 0xe9, 0x10, 0x6b, 0xc3, 0x6b, 0x62, 0xab, 0xee, 0xd0, 0x4d, 0xab, 0xe1, 0x63, 0x6c, 0x98,
	0xa3, 0xda, 0xd8, 0x99, 0xc9, 0x9e, 0x6b, 0xd1, 0xcd, 0xda, 0xb5, 0x15, 0xe7, 0x4d, 0x3c, 0xfd,
	0xf2, 0x47, 0xa1, 0x79, 0x8c, 0xef, 0xc4, 0xa6, 0x43, 0x5e, 0xf5, 0x9a, 0x78, 0xd6, 0xa1, 0x9b,
	0x73, 0x3e, 0xc6, 0xe9, 0xea, 0x28, 0xc8, 0xe5, 0x7d, 0x30, 0x7a, 0x85, 0x13, 0x39, 0x31, 0x31,
	0x7a, 0x05, 0x16, 0xbb, 0x83, 0xfb, 0x9a, 0xde, 0x93, 0xac, 0x77, 0x71, 0xec, 0x8c, 0x8a, 0x63,
	0xe7, 0x4f, 0x22, 0xe5, 0x49, 0x16, 0x6d, 0x74, 0xf8, 0x9c, 0xf1, 0xb3, 0x66, 0x27, 0x34, 0x67,
	0x93, 0x8a, 0x23, 0x91, 0x29, 0x0e, 0xa2, 0x78, 0x07, 0xd0, 0xc2, 0x99, 0xd2, 0xc4, 0x0c, 0x5d,
	0xfb, 0x32, 0xf5, 0x08, 0x8f, 0xdd, 0x39, 0xb3, 0xf9, 0xe6, 0xd1, 0x7e, 0x75, 0xec, 0x61, 0x4d,
	0xf1, 0xfc, 0x48, 0xe2, 0x0b, 0x33, 0x3b, 0xbe, 0x0b, 0x5e, 0xd7, 0xfb, 0x91, 0xbb, 0xcd, 0xab,
	0xaf, 0xe8, 0x36, 0x81, 0x60, 0x46, 0x8d, 0x27, 0xc5, 0x25, 0x1e, 0x2f, 0x7a, 0xcf, 0x45, 0xa0,
	0xa8, 0xca, 0x97, 0x30, 0xe3, 0x0b, 0x7f, 0x30, 0x8a, 0x30, 0x39, 0x79, 0x05, 0x16, 0x15, 0xc1,
	0x7f, 0x35, 0x7d, 0xcc, 0xdb, 0xc2, 0xfe, 0xb6, 0xef, 0x30, 0x1e, 0x38, 0x9a, 0x1e, 0xc3, 0x56,
	0x1d, 0x6f, 0x39, 0x36, 0xb6, 0x08, 0x6a, 0x62, 0xca, 0xc3, 0x69, 0x5c, 0x08, 0x19, 0x95, 0xec,
	0x7a, 0x69, 0xf8, 0x6e, 0xd2, 0x09, 0x8a, 0x3e, 0xb3, 0x78, 0x6b, 0x89, 0xab, 0xb7, 0x43, 0xf3,
	0xb2, 0x57, 0x82, 0x1c, 0x1b, 0x0b, 0xf4, 0x2e, 0x99, 0x89, 0x4c, 0x75, 0x42, 0xf3, 0x25, 0x41,
	0xf0, 0x21, 0x74, 0xbb, 0x2f, 0x4a, 0x5e, 0xc5, 0x75, 0xe1, 0x01, 0x1f, 0x86, 0x05, 0xf8, 0xaa,
	0x7e, 0x9e, 0x87, 0x31, 0xcb, 0x21, 0x75, 0xbc, 0x63, 0xf1, 0x95, 0x5c, 0x73, 0x3d, 0x7b, 0x93,
	0x1a, 0x97, 0xc5, 0x96, 0xe6, 0x8b, 0x06, 0x70, 0x85, 0x79, 0x8e, 0x2f, 0x3a, 0x64, 0x5a, 0xa0,
	0xe9, 0xad, 0x6d, 0x19, 0x52, 0x66, 0xca, 0x51, 0xfe, 0x0b, 0x15, 0x96, 0xc0, 0x3f, 0x79, 0xba,
	0x4b, 0x90, 0xbd, 0x89, 0xeb, 0x16, 0xf1, 0x98, 0xd3, 0x70, 0x6c, 0x14, 0xdd, 0x3f, 0xd4, 0xa9,
	0x51, 0x15, 0xdf, 0xf7, 0x3d, 0x3e, 0xdd, 0x43, 0x6b, 0x91, 0xd2, 0x92, 0xa4, 0x33, 0x3f, 0xcb,
	0x67, 0x7b, 0x28, 0x50, 0x22, 0x9d, 0xd0, 0xbc, 0x18, 0x85, 0x76, 0x15, 0x2c, 0xee, 0x2a, 0x95,
	0x48, 0x67, 0xbf, 0xda, 0xc5, 0xe2, 0xde, 0x41, 0xb5, 0x0b, 0x0b, 0xa8, 0xec, 0x51, 0xa7, 0x00,
	0xea, 0x67, 0x99, 0x8f, 0x1a, 0x0d, 0xc7, 0xb6, 0x6c, 0x17, 0x51, 0x6a, 0x5c, 0x11, 0xd3, 0x7a,
	0x95, 0xd7, 0xcb, 0x31, 0x30, 0xc3, 0xe5, 0x9d, 0xd0, 0x04, 0xd1, 0x84, 0x4a, 0xc2, 0xf4, 0xa2,
	0x26, 0xa7, 0x0a, 0xee, 0xe9, 0x03, 0xf1, 0x14, 0x5b, 0x0d, 0xcf, 0xad, 0x63, 0xdf, 0x6a, 0x21,
	0xb6, 0x61, 0x3c, 0x25, 0x76, 0xfd, 0x14, 0x3f, 0x06, 0x62, 0x78, 0x4e, 0xa0, 0xcb, 0x88, 0x6d,
	0xa4, 0x21, 0xa6, 0x84, 0x48, 0x9f, 0xeb, 0x6d, 0xbe, 0xac, 0xb4, 0xb7, 0x61, 0xb9, 0x3b, 0xd8,
	0xd4, 0xfb, 0x28, 0x66, 0x96, 0xeb, 0x6d, 0x5b, 0x2d, 0xdf, 0xf1, 0x7c, 0x87, 0xed, 0x1a, 0x4f,
	0x8b, 0xad, 0xc0, 0xc7, 0xeb, 0xa5, 0x98, 0x2d, 0x78, 0xdb, 0xcb, 0x31, 0x92, 0x0e, 0x96, 0x17,
	0x77, 0x4d, 0x2c, 0x0a, 0xdd, 0xc1, 0xfb, 0x9a, 0x3e, 0xd4, 0x44, 0x3b, 0x89, 0x73, 0xb6, 0x47,
	0xec, 0xc0, 0xf7, 0x31, 0xb1, 0x77, 0x8d, 0x31, 0x31, 0x7b, 0x54, 0x5c, 0xb1, 0xa0, 0xed, 0x45,
	0xb4, 0x13, 0x71, 0x9c, 0xc9, 0x54, 0xf8, 0x41, 0xdf, 0x54, 0xc8, 0xd3, 0x83, 0x5e, 0x05, 0x26,
	0x13, 0x2d, 0xee, 0x44, 0xd4, 0x76, 0xa1, 0xd2, 0x2a, 0xf8, 0x58, 0xd3, 0x07, 0x6c, 0x1f, 0xd1,
	0x8d, 0x42, 0xe6, 0xff, 0x8c, 0xf8, 0x18, 0x1f, 0x88, 0xcc, 0x7f, 0x26, 0xc9, 0xfc, 0xed, 0x38,
	0xf3, 0x9f, 0x8b, 0x4e, 0x64, 0xde, 0x2d, 0xcb, 0xc1, 0x95, 0xc1, 0x57, 0xe8, 0x94, 0xb3, 0x79,
	0x21, 0xe6, 0x2b, 0xb8, 0xbf, 0x64, 0x84, 0xd7, 0x04, 0x76, 0x5c, 0x13, 0x54, 0x1f, 0xc6, 0x0c,
	0xaf, 0x0a, 0x66, 0xa2, 0xaa, 0xa0, 0x60, 0xcc, 0x77, 0xc1, 0x4f, 0x35, 0x7d, 0xb8, 0xe8, 0x5e,
	0x72, 0x19, 0xf3, 0xac, 0xf8, 0xfe, 0xce, 0x61, 0x68, 0x9e, 0x9e, 0x81, 0xd2, 0x3b, 0x42, 0xde,
	0x4a, 0xf1, 0x1d, 0x41, 0x89, 0x76, 0x5b, 0x1a, 0x7b, 0x07, 0xd5, 0xcc, 0x36, 0x54, 0x5b, 0x06,
	0x5f, 0xd7, 0xf4, 0x21, 0xca, 0x02, 0x62, 0xf1, 0x7c, 0x09, 0xb9, 0xce, 0x16, 0xb6, 0xa2, 0x2c,
	0x98, 0x1a, 0xcf, 0xa5, 0x59, 0xe8, 0x00, 0xd7, 0xb8, 0x93, 0x28, 0xac, 0x70, 0x7c, 0x25, 0xcd,
	0x8d, 0x14, 0x58, 0x3e, 0x85, 0x97, 0xc2, 0xd8, 0x89, 0x89, 0x5b, 0xe3, 0x50, 0x65, 0x8d, 0x57,
	0xc6, 0x05, 0x1a, 0x3c, 0x9a, 0x52, 0xe3, 0x79, 0x41, 0xe2, 0x35, 0xbe, 0x2f, 0x73, 0xdd, 0x16,
	0x1d, 0x92, 0x55, 0x10, 0x25, 0x44, 0xce, 0x0c, 0x73, 0x61, 0x74, 0x72, 0x1c, 0x96, 0xed, 0xf0,
	0x5c, 0xbc, 0x47, 0x8c, 0x9e, 0x3c, 0x6f, 0x5d, 0x15, 0x91, 0xb3, 0x7e, 0x18, 0x9a, 0xbd, 0x10,
	0x6d, 0xaf, 0xb0, 0x40, 0x7a, 0xd8, 0x3a, 0x43, 0xb3, 0x66, 0x7a, 0x05, 0x95, 0xc9, 0x1e, 0xf8,
	0xf8, 0x56, 0xb0, 0x08, 0x65, 0x7b, 0x60, 0x4b, 0x3f, 0xc7, 0x8b, 0xcd, 0x1a, 0xa2, 0xd8, 0x8a,
	0x5e, 0x1a, 0x8d, 0x6b, 0xa3, 0xda, 0x58, 0xef, 0x64, 0x6f, 0x92, 0x0c, 0xad, 0x0a, 0xa9, 0xb8,
	0x33, 0xec, 0x4d, 0x54, 0x23, 0x59, 0x16, 0xa6, 0x72, 0xe2, 0xca, 0x68, 0x5c, 0x7a, 0xc4, 0xcb,
	0xe3, 0x9d, 0x83, 0xaa, 0x06, 0x0b, 0x5d, 0xc1, 0xf7, 0x8e, 0xeb, 0x97, 0x79, 0xd4, 0x48, 0xc3,
	0x05, 0x2f, 0x5d, 0x6d, 0xaf, 0xc9, 0x97, 0xac, 0x8f, 0xef, 0x05, 0x98, 0x32, 0x6b, 0xd3, 0xa9,
	0x19, 0xd7, 0xc5, 0xe7, 0xf8, 0xab, 0x16, 0xbf, 0x50, 0x2e, 0xa2, 0x9d, 0x99, 0x79, 0x18, 0xe1,
	0x77, 0x9c, 0xe9, 0x76, 0x68, 0x9a, 0x4d, 0xb4, 0x93, 0x6e, 0x71, 0x36, 0x1f, 0xdb, 0xc8, 0x54,
	0xd2, 0xb3, 0xef, 0x01, 0x7a, 0x52, 0xd9, 0xf7, 0x40, 0x93, 0x0f, 0x56, 0x89, 0xdf, 0x3c, 0x0b,
	0x74, 0xe1, 0x03, 0xba, 0xd5, 0xc0, 0xa7, 0x9a, 0x3e, 0x94, 0x3e, 0xbc, 0xb8, 0x48, 0x7e, 0xaa,
	0x1d, 0x17, 0x1b, 0xf8, 0x43, 0x3e, 0x13, 0x83, 0xc9, 0xc3, 0xc5, 0xc2, 0xd4, 0x92, 0xfc, 0x5a,
	0x3b, 0x88, 0x14, 0xf2, 0x34, 0x7d, 0x56, 0x81, 0xaa, 0xf7, 0x32, 0xa5, 0x91, 0x2e, 0x72, 0x69,
	0xeb, 0x2b, 0x49, 0xc1, 0xac, 0x17, 0x92, 0x9e, 0x7a, 0xb7, 0xf4, 0x0b, 0xe2, 0x6d, 0xa5, 0x11,
	0xb8, 0x6e, 0x9c, 0xcb, 0x78, 0x24, 0x29, 0x4c, 0x8d, 0x09, 0xe1, 0xe9, 0x6d, 0x9e, 0x2b, 0x70,
	0xad, 0xb9, 0xc0, 0x75, 0x45, 0x16, 0x72, 0x97, 0xc4, 0xa5, 0x64, 0x27, 0x34, 0x2f, 0xc5, 0x47,
	0x96, 0x0a, 0xae, 0xc0, 0x2e, 0xfd, 0xc0, 0x6b, 0xfa, 0xd9, 0x06, 0x46, 0x2c, 0xf0, 0xb1, 0xd5,
	0x70, 0xd1, 0x3a, 0x35, 0x26, 0xc5, 0xbe, 0xbb, 0xc2, 0xcf, 0xf7, 0x18, 0x98, 0xe3, 0xf2, 0xf4,
	0x1d, 0x46, 0x12, 0x56, 0x60, 0x4e, 0x05, 0xec, 0xea, 0xfd, 0xd2, 0xf3, 0x8b, 0x28, 0x36, 0xa8,
	0x71, 0x43, 0x14, 0x12, 0x46, 0xb2, 0x77, 0x66, 0x52, 0x85, 0x05, 0x81, 0x4f, 0x4f, 0xc6, 0x45,
	0x45, 0x9f, 0x5d, 0x40, 0x3a, 0xa1, 0x39, 0x14, 0x45, 0xdc, 0x02, 0x50, 0x81, 0x25, 0x5d, 0xf0,
	0x96, 0xde, 0x13, 0xb4, 0x48, 0x2b, 0x8d, 0xed, 0xbf, 0x9c, 0x13, 0x33, 0xf6, 0x85, 0xc3, 0xd0,
	0x3c, 0x3f, 0x8b, 0x5b, 0x3e, 0xb6, 0x11, 0xc3, 0xf5, 0xb5, 0x65, 0xb2, 0x9c, 0x05, 0x7a, 0xed,
	0x6a, 0x96, 0x61, 0xb5, 0x48, 0x2b, 0x06, 0x9e, 0xf7, 0x9a, 0x0e, 0xcf, 0xf2, 0xd8, 0x6e, 0x65,
	0xef, 0xa0, 0xaa, 0xee, 0x6c, 0x68, 0xf0, 0x8c, 0xd4, 0x05, 0xfc, 0x5c, 0x8b, 0x87, 0x4f, 0xee,
	0xcf, 0xdf, 0x9f, 0x13, 0x9b, 0xf4, 0x1d, 0xb1, 0x34, 0xf3, 0x26, 0xd2, 0xbb, 0x74, 0x31, 0xfc,
	0x68, 0x3a, 0xbc, 0x7c, 0x07, 0x2e, 0x71, 0xc8, 0xf6, 0xe0, 0x85, 0xee, 0x5a, 0x7c, 0xad, 0xa9,
	0x46, 0x31, 0x34, 0xa8, 0x67, 0xbd, 0xc0, 0x6f, 0x35, 0xbd, 0x57, 0xd0, 0xcc, 0x6e, 0xca, 0x7f,
	0x15, 0x11, 0xfd, 0x96, 0x48, 0x50, 0xf3, 0x26, 0xa4, 0x5b, 0x73, 0x41, 0xb5, 0x92, 0x52, 0xcd,
	0xdf, 0x73, 0x2b, 0xc9, 0x5e, 0xfa, 0x2c, 0x3d, 0x9e, 0x86, 0xaa, 0xc7, 0x32, 0x34, 0xd8, 0x23,
	0xf7, 0xcc, 0x28, 0x67, 0xf7, 0xe1, 0x1f, 0x74, 0xa7, 0x2c, 0xdd, 0x8d, 0x17, 0x28, 0xe7, 0x6f,
	0xb3, 0xbb, 0x53, 0xee, 0xa6, 0x57, 0xa6, 0x9c, 0x68, 0x26, 0x94, 0xd3, 0xeb, 0xef, 0x86, 0x1e,
	0xbd, 0xbb, 0xa5, 0x27, 0xd9, 0xaf, 0xe7, 0xc4, 0x96, 0xfa, 0x7c, 0x9e, 0xaf, 0x78, 0xba, 0xca,
	0x8e, 0x34, 0x69, 0x31, 0xfa, 0x19, 0x22, 0x11, 0xe5, 0xe3, 0x48, 0x08, 0x15, 0xb7, 0x07, 0xe5,
	0xc2, 0xdd, 0x6a, 0xd9, 0xcc, 0xf8, 0x90, 0x4f, 0x91, 0x36, 0xbd, 0x78, 0x18, 0x9a, 0x97, 0xb2,
	0x11, 0x17, 0xf3, 0x65, 0xf7, 0xb2, 0xcd, 0xf2, 0xf3, 0xd4, 0x2c, 0xe1, 0xf9, 0xe1, 0x41, 0x59,
	0x81, 0x1f, 0xdb, 0x83, 0x85, 0x43, 0x8b, 0xda, 0x88, 0x50, 0xe3, 0x37, 0xd1, 0x57, 0x5a, 0x2d,
	0x50, 0x90, 0x83, 0xfd, 0x0a, 0x57, 0x2c, 0x50, 0x28, 0xe1, 0xe5, 0x4f, 0x25, 0x98, 0x94, 0xf4,
	0x2a, 0x6f, 0xe9, 0x7d, 0xc5, 0xd8, 0x02, 0x5e, 0xd2, 0x4f, 0x61, 0xe2, 0x05, 0xeb, 0x1b, 0x86,
	0x26, 0xd8, 0x3c, 0xd9, 0x0e, 0xcd, 0x58, 0x92, 0xde, 0xe9, 0x47, 0xcd, 0xb4, 0x52, 0x89, 0x61,
	0x70, 0x55, 0x3f, 0xd1, 0x44, 0x3b, 0xc6, 0x71, 0xd1, 0xef, 0x62, 0x3b, 0x34, 0x79, 0xb3, 0x13,
	0x9a, 0xa7, 0x13, 0x9e, 0x69, 0x0f, 0x0e, 0x4c, 0xdf, 0xf9, 0xe8, 0x93, 0x91, 0x63, 0x07, 0x9f,
	0x8c, 0x1c, 0xfb, 0xe8, 0x70, 0x44, 0x3b, 0x38, 0x1c, 0xd1, 0xbe, 0x73, 0x7f, 0xe4, 0xd8, 0x7b,
	0xf7, 0x47, 0xb4, 0x83, 0xfb, 0x23, 0xc7, 0xfe, 0x71, 0x7f, 0xe4, 0xd8, 0x1b, 0xcf, 0xac, 0x3b,
	0x6c, 0x23, 0xa8, 0x5d, 0xb3, 0xbd, 0xe6, 0xf5, 0x34, 0x91, 0x95, 0x7e, 0x65, 0x7f, 0x63, 0xaa,
	0x9d, 0x12, 0xff, 0x5b, 0xba, 0xf1, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x60, 0xbd, 0x8f, 0x28,
	0x23, 0x25, 0x00, 0x00,
}

func (m *OptionsConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptionsConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptionsConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeprecatedMaxConcurrentScans != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.DeprecatedMaxConcurrentScans))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xf0
	}
	if m.DeprecatedMinHomeDiskFreePct != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DeprecatedMinHomeDiskFreePct))))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xe9
	}
	if len(m.DeprecatedRelayServers) > 0 {
		for iNdEx := len(m.DeprecatedRelayServers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DeprecatedRelayServers[iNdEx])
			copy(dAtA[i:], m.DeprecatedRelayServers[iNdEx])
			i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.DeprecatedRelayServers[iNdEx])))
			i--
			dAtA[i] = 0x4
			i--
			dAtA[i] = 0xb2
			i--
			dAtA[i] = 0xe2
		}
	}
	if m.DeprecatedUPnPTimeoutS != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.DeprecatedUPnPTimeoutS))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xd8
	}
	if m.DeprecatedUPnPRenewalM != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.DeprecatedUPnPRenewalM))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xd0
	}
	if m.DeprecatedUPnPLeaseM != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.DeprecatedUPnPLeaseM))
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xc8
	}
	if m.DeprecatedUPnPEnabled {
		i--
		if m.DeprecatedUPnPEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x4
		i--
		dAtA[i] = 0xb2
		i--
		dAtA[i] = 0xc0
	}
	{
		size, err := m.ConnectionLimits.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3
	i--
	dAtA[i] = 0x9a
	if len(m.FeatureFlags) > 0 {
		for iNdEx := len(m.FeatureFlags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FeatureFlags[iNdEx])
			copy(dAtA[i:], m.FeatureFlags[iNdEx])
			i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.FeatureFlags[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	if m.SendFullIndexOnUpgrade {
		i--
		if m.SendFullIndexOnUpgrade {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x88
	}
	if m.AnnounceLANAddresses {
		i--
		if m.AnnounceLANAddresses {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.RawMaxCIRequestKiB != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.RawMaxCIRequestKiB))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.DatabaseTuning != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.DatabaseTuning))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if len(m.RawStunServers) > 0 {
		for iNdEx := len(m.RawStunServers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RawStunServers[iNdEx])
			copy(dAtA[i:], m.RawStunServers[iNdEx])
			i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.RawStunServers[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xea
		}
	}
	if m.StunKeepaliveMinS != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.StunKeepaliveMinS))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.StunKeepaliveStartS != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.StunKeepaliveStartS))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.CREnabled {
		i--
		if m.CREnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if len(m.CRURL) > 0 {
		i -= len(m.CRURL)
		copy(dAtA[i:], m.CRURL)
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.CRURL)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.RawMaxFolderConcurrency != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.RawMaxFolderConcurrency))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.SetLowPriority {
		i--
		if m.SetLowPriority {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if len(m.DefaultFolderPath) > 0 {
		i -= len(m.DefaultFolderPath)
		copy(dAtA[i:], m.DefaultFolderPath)
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.DefaultFolderPath)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb2
	}
	if m.TrafficClass != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.TrafficClass))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if len(m.UnackedNotificationIDs) > 0 {
		for iNdEx := len(m.UnackedNotificationIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UnackedNotificationIDs[iNdEx])
			copy(dAtA[i:], m.UnackedNotificationIDs[iNdEx])
			i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.UnackedNotificationIDs[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.TempIndexMinBlocks != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.TempIndexMinBlocks))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.OverwriteRemoteDevNames {
		i--
		if m.OverwriteRemoteDevNames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if len(m.AlwaysLocalNets) > 0 {
		for iNdEx := len(m.AlwaysLocalNets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlwaysLocalNets[iNdEx])
			copy(dAtA[i:], m.AlwaysLocalNets[iNdEx])
			i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.AlwaysLocalNets[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.ReleasesURL) > 0 {
		i -= len(m.ReleasesURL)
		copy(dAtA[i:], m.ReleasesURL)
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.ReleasesURL)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	{
		size, err := m.MinHomeDiskFree.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xfa
	if m.LimitBandwidthInLan {
		i--
		if m.LimitBandwidthInLan {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.ProgressUpdateIntervalS != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.ProgressUpdateIntervalS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.CacheIgnoredFiles {
		i--
		if m.CacheIgnoredFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.KeepTemporariesH != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.KeepTemporariesH))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.UpgradeToPreReleases {
		i--
		if m.UpgradeToPreReleases {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.AutoUpgradeIntervalH != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.AutoUpgradeIntervalH))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.RestartOnWakeup {
		i--
		if m.RestartOnWakeup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.URInitialDelayS != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.URInitialDelayS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.URPostInsecurely {
		i--
		if m.URPostInsecurely {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.URURL) > 0 {
		i -= len(m.URURL)
		copy(dAtA[i:], m.URURL)
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.URURL)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.URUniqueID) > 0 {
		i -= len(m.URUniqueID)
		copy(dAtA[i:], m.URUniqueID)
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.URUniqueID)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.URSeen != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.URSeen))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.URAccepted != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.URAccepted))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.NATTimeoutS != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.NATTimeoutS))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.NATRenewalM != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.NATRenewalM))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.NATLeaseM != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.NATLeaseM))
		i--
		dAtA[i] = 0x78
	}
	if m.NATEnabled {
		i--
		if m.NATEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.StartBrowser {
		i--
		if m.StartBrowser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.RelayReconnectIntervalM != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.RelayReconnectIntervalM))
		i--
		dAtA[i] = 0x58
	}
	if m.RelaysEnabled {
		i--
		if m.RelaysEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.ReconnectIntervalS != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.ReconnectIntervalS))
		i--
		dAtA[i] = 0x48
	}
	if m.MaxRecvKbps != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.MaxRecvKbps))
		i--
		dAtA[i] = 0x40
	}
	if m.MaxSendKbps != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.MaxSendKbps))
		i--
		dAtA[i] = 0x38
	}
	if len(m.LocalAnnMCAddr) > 0 {
		i -= len(m.LocalAnnMCAddr)
		copy(dAtA[i:], m.LocalAnnMCAddr)
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.LocalAnnMCAddr)))
		i--
		dAtA[i] = 0x32
	}
	if m.LocalAnnPort != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.LocalAnnPort))
		i--
		dAtA[i] = 0x28
	}
	if m.LocalAnnEnabled {
		i--
		if m.LocalAnnEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.GlobalAnnEnabled {
		i--
		if m.GlobalAnnEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.RawGlobalAnnServers) > 0 {
		for iNdEx := len(m.RawGlobalAnnServers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RawGlobalAnnServers[iNdEx])
			copy(dAtA[i:], m.RawGlobalAnnServers[iNdEx])
			i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.RawGlobalAnnServers[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RawListenAddresses) > 0 {
		for iNdEx := len(m.RawListenAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RawListenAddresses[iNdEx])
			copy(dAtA[i:], m.RawListenAddresses[iNdEx])
			i = encodeVarintOptionsconfiguration(dAtA, i, uint64(len(m.RawListenAddresses[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConnectionLimits) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectionLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Max != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.Max))
		i--
		dAtA[i] = 0x10
	}
	if m.Enough != 0 {
		i = encodeVarintOptionsconfiguration(dAtA, i, uint64(m.Enough))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintOptionsconfiguration(dAtA []byte, offset int, v uint64) int {
	offset -= sovOptionsconfiguration(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OptionsConfiguration) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RawListenAddresses) > 0 {
		for _, s := range m.RawListenAddresses {
			l = len(s)
			n += 1 + l + sovOptionsconfiguration(uint64(l))
		}
	}
	if len(m.RawGlobalAnnServers) > 0 {
		for _, s := range m.RawGlobalAnnServers {
			l = len(s)
			n += 1 + l + sovOptionsconfiguration(uint64(l))
		}
	}
	if m.GlobalAnnEnabled {
		n += 2
	}
	if m.LocalAnnEnabled {
		n += 2
	}
	if m.LocalAnnPort != 0 {
		n += 1 + sovOptionsconfiguration(uint64(m.LocalAnnPort))
	}
	l = len(m.LocalAnnMCAddr)
	if l > 0 {
		n += 1 + l + sovOptionsconfiguration(uint64(l))
	}
	if m.MaxSendKbps != 0 {
		n += 1 + sovOptionsconfiguration(uint64(m.MaxSendKbps))
	}
	if m.MaxRecvKbps != 0 {
		n += 1 + sovOptionsconfiguration(uint64(m.MaxRecvKbps))
	}
	if m.ReconnectIntervalS != 0 {
		n += 1 + sovOptionsconfiguration(uint64(m.ReconnectIntervalS))
	}
	if m.RelaysEnabled {
		n += 2
	}
	if m.RelayReconnectIntervalM != 0 {
		n += 1 + sovOptionsconfiguration(uint64(m.RelayReconnectIntervalM))
	}
	if m.StartBrowser {
		n += 2
	}
	if m.NATEnabled {
		n += 2
	}
	if m.NATLeaseM != 0 {
		n += 1 + sovOptionsconfiguration(uint64(m.NATLeaseM))
	}
	if m.NATRenewalM != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.NATRenewalM))
	}
	if m.NATTimeoutS != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.NATTimeoutS))
	}
	if m.URAccepted != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.URAccepted))
	}
	if m.URSeen != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.URSeen))
	}
	l = len(m.URUniqueID)
	if l > 0 {
		n += 2 + l + sovOptionsconfiguration(uint64(l))
	}
	l = len(m.URURL)
	if l > 0 {
		n += 2 + l + sovOptionsconfiguration(uint64(l))
	}
	if m.URPostInsecurely {
		n += 3
	}
	if m.URInitialDelayS != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.URInitialDelayS))
	}
	if m.RestartOnWakeup {
		n += 3
	}
	if m.AutoUpgradeIntervalH != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.AutoUpgradeIntervalH))
	}
	if m.UpgradeToPreReleases {
		n += 3
	}
	if m.KeepTemporariesH != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.KeepTemporariesH))
	}
	if m.CacheIgnoredFiles {
		n += 3
	}
	if m.ProgressUpdateIntervalS != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.ProgressUpdateIntervalS))
	}
	if m.LimitBandwidthInLan {
		n += 3
	}
	l = m.MinHomeDiskFree.ProtoSize()
	n += 2 + l + sovOptionsconfiguration(uint64(l))
	l = len(m.ReleasesURL)
	if l > 0 {
		n += 2 + l + sovOptionsconfiguration(uint64(l))
	}
	if len(m.AlwaysLocalNets) > 0 {
		for _, s := range m.AlwaysLocalNets {
			l = len(s)
			n += 2 + l + sovOptionsconfiguration(uint64(l))
		}
	}
	if m.OverwriteRemoteDevNames {
		n += 3
	}
	if m.TempIndexMinBlocks != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.TempIndexMinBlocks))
	}
	if len(m.UnackedNotificationIDs) > 0 {
		for _, s := range m.UnackedNotificationIDs {
			l = len(s)
			n += 2 + l + sovOptionsconfiguration(uint64(l))
		}
	}
	if m.TrafficClass != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.TrafficClass))
	}
	l = len(m.DefaultFolderPath)
	if l > 0 {
		n += 2 + l + sovOptionsconfiguration(uint64(l))
	}
	if m.SetLowPriority {
		n += 3
	}
	if m.RawMaxFolderConcurrency != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.RawMaxFolderConcurrency))
	}
	l = len(m.CRURL)
	if l > 0 {
		n += 2 + l + sovOptionsconfiguration(uint64(l))
	}
	if m.CREnabled {
		n += 3
	}
	if m.StunKeepaliveStartS != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.StunKeepaliveStartS))
	}
	if m.StunKeepaliveMinS != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.StunKeepaliveMinS))
	}
	if len(m.RawStunServers) > 0 {
		for _, s := range m.RawStunServers {
			l = len(s)
			n += 2 + l + sovOptionsconfiguration(uint64(l))
		}
	}
	if m.DatabaseTuning != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.DatabaseTuning))
	}
	if m.RawMaxCIRequestKiB != 0 {
		n += 2 + sovOptionsconfiguration(uint64(m.RawMaxCIRequestKiB))
	}
	if m.AnnounceLANAddresses {
		n += 3
	}
	if m.SendFullIndexOnUpgrade {
		n += 3
	}
	if len(m.FeatureFlags) > 0 {
		for _, s := range m.FeatureFlags {
			l = len(s)
			n += 2 + l + sovOptionsconfiguration(uint64(l))
		}
	}
	l = m.ConnectionLimits.ProtoSize()
	n += 2 + l + sovOptionsconfiguration(uint64(l))
	if m.DeprecatedUPnPEnabled {
		n += 4
	}
	if m.DeprecatedUPnPLeaseM != 0 {
		n += 3 + sovOptionsconfiguration(uint64(m.DeprecatedUPnPLeaseM))
	}
	if m.DeprecatedUPnPRenewalM != 0 {
		n += 3 + sovOptionsconfiguration(uint64(m.DeprecatedUPnPRenewalM))
	}
	if m.DeprecatedUPnPTimeoutS != 0 {
		n += 3 + sovOptionsconfiguration(uint64(m.DeprecatedUPnPTimeoutS))
	}
	if len(m.DeprecatedRelayServers) > 0 {
		for _, s := range m.DeprecatedRelayServers {
			l = len(s)
			n += 3 + l + sovOptionsconfiguration(uint64(l))
		}
	}
	if m.DeprecatedMinHomeDiskFreePct != 0 {
		n += 11
	}
	if m.DeprecatedMaxConcurrentScans != 0 {
		n += 3 + sovOptionsconfiguration(uint64(m.DeprecatedMaxConcurrentScans))
	}
	return n
}

func (m *ConnectionLimits) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enough != 0 {
		n += 1 + sovOptionsconfiguration(uint64(m.Enough))
	}
	if m.Max != 0 {
		n += 1 + sovOptionsconfiguration(uint64(m.Max))
	}
	return n
}

func sovOptionsconfiguration(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOptionsconfiguration(x uint64) (n int) {
	return sovOptionsconfiguration(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OptionsConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptionsconfiguration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptionsConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptionsConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawListenAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawListenAddresses = append(m.RawListenAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawGlobalAnnServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawGlobalAnnServers = append(m.RawGlobalAnnServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalAnnEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GlobalAnnEnabled = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAnnEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalAnnEnabled = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAnnPort", wireType)
			}
			m.LocalAnnPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalAnnPort |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalAnnMCAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalAnnMCAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSendKbps", wireType)
			}
			m.MaxSendKbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSendKbps |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRecvKbps", wireType)
			}
			m.MaxRecvKbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRecvKbps |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReconnectIntervalS", wireType)
			}
			m.ReconnectIntervalS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReconnectIntervalS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelaysEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RelaysEnabled = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayReconnectIntervalM", wireType)
			}
			m.RelayReconnectIntervalM = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayReconnectIntervalM |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartBrowser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartBrowser = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NATEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NATEnabled = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NATLeaseM", wireType)
			}
			m.NATLeaseM = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NATLeaseM |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NATRenewalM", wireType)
			}
			m.NATRenewalM = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NATRenewalM |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NATTimeoutS", wireType)
			}
			m.NATTimeoutS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NATTimeoutS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URAccepted", wireType)
			}
			m.URAccepted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.URAccepted |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URSeen", wireType)
			}
			m.URSeen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.URSeen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URUniqueID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URUniqueID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URPostInsecurely", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.URPostInsecurely = bool(v != 0)
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field URInitialDelayS", wireType)
			}
			m.URInitialDelayS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.URInitialDelayS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartOnWakeup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RestartOnWakeup = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoUpgradeIntervalH", wireType)
			}
			m.AutoUpgradeIntervalH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoUpgradeIntervalH |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeToPreReleases", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpgradeToPreReleases = bool(v != 0)
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepTemporariesH", wireType)
			}
			m.KeepTemporariesH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeepTemporariesH |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheIgnoredFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheIgnoredFiles = bool(v != 0)
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressUpdateIntervalS", wireType)
			}
			m.ProgressUpdateIntervalS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProgressUpdateIntervalS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitBandwidthInLan", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LimitBandwidthInLan = bool(v != 0)
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinHomeDiskFree", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinHomeDiskFree.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasesURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleasesURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysLocalNets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlwaysLocalNets = append(m.AlwaysLocalNets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverwriteRemoteDevNames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OverwriteRemoteDevNames = bool(v != 0)
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempIndexMinBlocks", wireType)
			}
			m.TempIndexMinBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempIndexMinBlocks |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnackedNotificationIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnackedNotificationIDs = append(m.UnackedNotificationIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficClass", wireType)
			}
			m.TrafficClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrafficClass |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFolderPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultFolderPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetLowPriority", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetLowPriority = bool(v != 0)
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawMaxFolderConcurrency", wireType)
			}
			m.RawMaxFolderConcurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawMaxFolderConcurrency |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CRURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CRURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CREnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CREnabled = bool(v != 0)
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StunKeepaliveStartS", wireType)
			}
			m.StunKeepaliveStartS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StunKeepaliveStartS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StunKeepaliveMinS", wireType)
			}
			m.StunKeepaliveMinS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StunKeepaliveMinS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawStunServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawStunServers = append(m.RawStunServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatabaseTuning", wireType)
			}
			m.DatabaseTuning = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatabaseTuning |= Tuning(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawMaxCIRequestKiB", wireType)
			}
			m.RawMaxCIRequestKiB = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawMaxCIRequestKiB |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnnounceLANAddresses", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AnnounceLANAddresses = bool(v != 0)
		case 49:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendFullIndexOnUpgrade", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendFullIndexOnUpgrade = bool(v != 0)
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureFlags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeatureFlags = append(m.FeatureFlags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConnectionLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9000:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedUPnPEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeprecatedUPnPEnabled = bool(v != 0)
		case 9001:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedUPnPLeaseM", wireType)
			}
			m.DeprecatedUPnPLeaseM = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedUPnPLeaseM |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9002:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedUPnPRenewalM", wireType)
			}
			m.DeprecatedUPnPRenewalM = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedUPnPRenewalM |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9003:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedUPnPTimeoutS", wireType)
			}
			m.DeprecatedUPnPTimeoutS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedUPnPTimeoutS |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9004:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedRelayServers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeprecatedRelayServers = append(m.DeprecatedRelayServers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9005:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedMinHomeDiskFreePct", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.DeprecatedMinHomeDiskFreePct = float64(math.Float64frombits(v))
		case 9006:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedMaxConcurrentScans", wireType)
			}
			m.DeprecatedMaxConcurrentScans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeprecatedMaxConcurrentScans |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOptionsconfiguration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOptionsconfiguration
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enough", wireType)
			}
			m.Enough = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Enough |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOptionsconfiguration(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthOptionsconfiguration
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOptionsconfiguration(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOptionsconfiguration
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOptionsconfiguration
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOptionsconfiguration
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOptionsconfiguration
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOptionsconfiguration
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOptionsconfiguration        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOptionsconfiguration          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOptionsconfiguration = fmt.Errorf("proto: unexpected end of group")
)
